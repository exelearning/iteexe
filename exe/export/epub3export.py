# ===========================================================================
# eXe 
# Copyright 2012, Pere Crespo Molina
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
# ===========================================================================
"""
Exports an eXe package as a Epub3 package
"""

import logging
import re
import time
from cgi                           import escape
from zipfile                       import ZipFile, ZIP_DEFLATED, ZIP_STORED
from exe.webui                     import common
from exe.webui.blockfactory        import g_blockFactory
from exe.engine.error              import Error
from exe.engine.path               import Path, TempDirPath
from exe.export.pages              import Page, uniquifyNames
from exe.engine.uniqueidgenerator  import UniqueIdGenerator
from exe                      	   import globals as G

log = logging.getLogger(__name__)


# ===========================================================================
class PublicationEpub3(object):
    """
    EPUB Publications 3.0, defines publication-level semantics and conformance requirements for EPUB 3, 
    including the format of the Package Document and rules for how this document and other 
    Publication Resources are associated to create a conforming EPUB Publication
    """
    
    def __init__(self, config, outputDir, package, pages):
        """
        Initialize
        'outputDir' is the directory that we read the html from and also output
        the mainfest.xml 
        """
        self.config       = config
        self.outputDir    = outputDir
        self.package      = package
        self.pages        = pages
        self.idGenerator  = UniqueIdGenerator(package.name, config.exePath)
    
    def save(self, filename):
        """
        Save a publication.opf file to self.outputDir
        """
        out = open(self.outputDir/filename, "w")
        out.write(self.createXML().encode("utf8"))
        out.close()
    
    def createXML(self):
        """
        returning XLM string for publication.opf file
        """
        xmlStr = """<?xml version="1.0" encoding="UTF-8"?>
        <!-- generated by eXe - http://exelearning.org -->
        <package version="3.0" xmlns="http://www.idpf.org/2007/opf" unique-identifier="pub-id">        
        """
        xmlStr += self.createMetadata()
        xmlStr += self.createManifest()
        xmlStr += self.createSpine()
        
        xmlStr += "</package>"
        return xmlStr

    def createManifest(self):
        import mimetypes

        xmlStr = u"<manifest>\n"

        xmlStr += u'<item id="nav" href="nav.xhtml" properties="nav" media-type="application/xhtml+xml" />\n'

        for epubFile in self.outputDir.walk():
            if epubFile.basename() == u'iteexe_project.opf':
                continue
            if epubFile.basename() == u'nav.xhtml':
                continue

            ext = epubFile.basename().split('.')[-1]
            
            mimetype, _ = mimetypes.guess_type(epubFile.abspath())
            if not mimetype:
                if ext and ext == 'webm':
                    mimetype = u'video/webm'

            properties = ''
            
            if ext == 'xhtml':
                properties = u'properties="scripted"'

            xmlStr += u'<item id="%s" href="%s" media-type="%s" %s/>\n' % (epubFile.basename().replace('.', '-'),
                                                                       self.outputDir.relpathto(epubFile),
                                                                       mimetype,
                                                                       properties)

        xmlStr += u"</manifest>\n"

        return xmlStr

    def createMetadata(self):
        """
        creator = unicode(self.package.dublinCore.creator or self.package.author or '', 'utf8')
        publisher = unicode(self.package.dublinCore.publisher or '', 'utf8')
        contributors = unicode(self.package.dublinCore.contributors or '', 'utf8')
        rights = unicode(self.package.dublinCore.contributors or '', 'utf8')
        title = unicode(self.package.dublinCore.title or self.package.title or '', 'utf8')
        language = unicode(self.package.dublinCore.language or G.application.config.locale, 'utf8')

        xmlStr = '<metadata xmlns:dc="http://purl.org/dc/elements/1.1/">' + \
            '<dc:identifier id="pub-id">urn:uuid:%s</dc:identifier>' % self.idGenerator.generate() + \
            '<dc:title>%s</dc:title>' % title + \
            '<dc:language>%s</dc:language>' % language

        xmlStr += '<dc:creator>%s</dc:creator>' % creator
        xmlStr += '<dc:publisher>%s</dc:publisher>' % publisher
        xmlStr += '<dc:contributors>%s</dc:contributors>' % contributors
        xmlStr += '<dc:rights>%s</dc:rights>' % rights

        xmlStr += '<meta property="dcterms:modified">%s</meta>' % time.strftime('%Y-%m-%dT%H:%M:%SZ') + '</metadata>'
        """
        lrm = self.package.dublinCore.__dict__.copy()
        if lrm.get('title', '') == '':
            lrm['title'] = self.package.title
        if lrm['title'] == '':
            lrm['title'] = self.package.name
        if lrm.get('description', '') == '':
            lrm['description'] = self.package.description
        if lrm['description'] == '':
            lrm['description'] = self.package.name
        if lrm.get('creator', '') == '':
            lrm['creator'] = self.package.author

        # Metadata
        templateFilename = self.config.webDir/'templates'/'dublincore.xml'
        template = open(templateFilename, 'rb').read()
        xml = template % lrm

        # Elimino la primera linea del xml: <?xml version="1.0"?>
        xml = "\n".join(xml.splitlines()[1:])

        return xml

    def createSpine(self):
        """
        Returning xml string for items and resources
        """
        xmlStr = u'<spine page-progression-direction="ltr">\n'
        xmlStr += u'<itemref idref="cover-xhtml" linear="no"/>\n'
        for page in self.pages:           
            if page.name == 'cover':
                continue
            xmlStr += self.genItemResStr(page)
        xmlStr += u'</spine>\n'
        return xmlStr

    def genItemResStr(self, page):
        itemStr = u"<itemref idref=\"" + page.name.replace('.', '-') + "-xhtml\" />\n"

        return itemStr

# ===========================================================================


class ContainerEpub3(object):
    """
    Represents an META-INF/container.xml file .Read EPUB Open Container Format (OCF) 3.0
    """

    def __init__(self, outputDir):
        """
        Initialize
        'outputDir' is the directory that we read the html from and also output
        the mainfest.xml 
        """

        self.outputDir = outputDir

    def save(self, filename):
        """
        Save a container.xml file to self.outputDir
        """
        out = open(self.outputDir/filename, "w")
        out.write(self.createXML().encode('utf8'))
        out.close()

    def createXML(self):
        """
        returning XLM string for META-INF/container.xml file
        """
                     
        xmlStr = u"""<?xml version="1.0"?>
            <container version="1.0" xmlns="urn:oasis:names:tc:opendocument:xmlns:container">
                <rootfiles>
                    <rootfile full-path="Content/iteexe_project.opf"
                        media-type="application/oebps-package+xml" />
                </rootfiles>
            </container>
        """
        return xmlStr


class NavEpub3(object):
    def __init__(self, pages, outputDir):
        self.pages = pages
        self.outputDir = outputDir

    def save(self):
        out = open(self.outputDir/'nav.xhtml', "w")
        out.write(self.createXML())
        out.close()

    def createXML(self):
        xmlStr = u"""<?xml version="1.0" encoding="UTF-8"?>
            <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"
                xmlns:epub="http://www.idpf.org/2007/ops">
                <head>
                    <meta charset="utf-8"></meta>
                </head>
                <body>
                    <nav epub:type="toc" id="toc">
                        <ol>
        """

        for page in self.pages:
            xmlStr += u"<li><a href=\"%s\">%s</a></li>\n" % (page.name + ".xhtml", page.node.title)

        xmlStr += u"""
                        </ol>
                    </nav>
                </body>
            </html>
        """

        return xmlStr


class Epub3Page(Page):
    """
    This class transforms an eXe node into a SCO
    """
    def __init__(self, name, depth, node):
        super(Epub3Page, self).__init__(name, depth, node)

    def save(self, outputDirPage):
        """
        This is the main function.  It will render the page and save it to a
        file.  
        'outputDirPage' is the name of the directory where the node will be saved to,
        the filename will be the 'self.node.id'.html or 'index.html' if
        self.node is the root node. 'outputDirPage' must be a 'Path' instance
        """
        out = open(outputDirPage/self.name + ".xhtml", "wb")
        out.write(self.render())
        out.close()

    def render(self):
        """
        Returns an XHTML string rendering this page.
        """
        dT = common.getExportDocType()
        lb = "\n" #Line breaks
        sectionTag = "div"
        headerTag = "div"
        if dT == "HTML5":
            sectionTag = "section"
            headerTag = "header"
        html  = common.docType()
        lenguaje = G.application.config.locale
        if self.node.package.dublinCore.language!="":
            lenguaje = self.node.package.dublinCore.language
        html += u"<html lang=\"" + lenguaje + "\" xml:lang=\"" + lenguaje + "\" xmlns=\"http://www.w3.org/1999/xhtml\">"+lb
        html += u"<head>"+lb
        html += u"<title>"
        if self.node.id=='0':
            if self.node.package.title!='':
                html += escape(self.node.package.title)
            else:
                html += escape(self.node.titleLong)
        else:
            if self.node.package.title!='':
                html += escape(self.node.titleLong)+" | "+escape(self.node.package.title)
            else:
                html += escape(self.node.titleLong)
        html += u" </title>"+lb
        html += u"<meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\" />"+lb
        if dT != "HTML5" and self.node.package.dublinCore.language!="":
            html += '<meta http-equiv="content-language" content="'+lenguaje+'" />'+lb
        if self.node.package.author!="":
            html += '<meta name="author" content="'+self.node.package.author+'" />'+lb
        html += '<meta name="generator" content="eXeLearning - exelearning.net" />'+lb
        if self.node.id=='0':
            if self.node.package.description!="":
                html += '<meta name="description" content="'+self.node.package.description+'" />'+lb
        html += u"<link rel=\"stylesheet\" type=\"text/css\" href=\"base.css\" />"+lb
        if common.hasWikipediaIdevice(self.node):
            html += u"<link rel=\"stylesheet\" type=\"text/css\" href=\"exe_wikipedia.css\" />"+lb
        if common.hasGalleryIdevice(self.node):
            html += u"<link rel=\"stylesheet\" type=\"text/css\" href=\"exe_lightbox.css\" />"+lb
        html += u"<link rel=\"stylesheet\" type=\"text/css\" href=\"content.css\" />"+lb
        if dT == "HTML5" or common.nodeHasMediaelement(self.node):
            html += u'<!--[if lt IE 9]><script type="text/javascript" src="exe_html5.js"></script><![endif]-->'+lb
        style = G.application.config.styleStore.getStyle(self.node.package.style)
        # Some styles might include eXe's jQuery
        if style.hasValidConfig:
            if style.get_jquery():
                html += u'<script type="text/javascript" src="exe_jquery.js"></script>'+lb
        if common.hasGalleryIdevice(self.node):
            html += u'<script type="text/javascript" src="exe_lightbox.js"></script>'+lb
        html += u'<script type="text/javascript" src="common.js"></script>'+lb
        if common.hasMagnifier(self.node):
            html += u'<script type="text/javascript" src="mojomagnify.js"></script>'+lb
        # Some styles might have their own JavaScript files (see their config.xml file)
        if style.hasValidConfig:
            html += style.get_extra_head()
        html += u"</head>"+lb
        html += u"<body class=\"exe-epub3\">"+lb
        html += u"<"+sectionTag+" id=\"outer\">"+lb
        html += u"<"+sectionTag+" id=\"main\">"+lb
        html += u"<"+headerTag+" id=\"nodeDecoration\">"
        html += u'<h1 id=\"nodeTitle\">'
        html += escape(self.node.titleLong)
        html += u'</h1>'
        html += u"</"+headerTag+">"+lb

        for idevice in self.node.idevices:
            if idevice.klass != 'NotaIdevice':
                e=" em_iDevice"
                if unicode(idevice.emphasis)=='0':
                    e=""
                html += u'<'+sectionTag+' class="iDevice_wrapper %s%s" id="id%s">%s' % (idevice.klass, e, idevice.id, lb)
                block = g_blockFactory.createBlock(None, idevice)
                if not block:
                    log.critical("Unable to render iDevice.")
                    raise Error("Unable to render iDevice.")
                if hasattr(idevice, "isQuiz"):
                    html += block.renderJavascriptForWeb()
                if idevice.title != "Forum Discussion":
                    html += self.processInternalLinks(
                        block.renderView(self.node.package.style))
            html += u'</'+sectionTag+'>'+lb # iDevice div

        html += u"</"+sectionTag+">"+lb # /#main
        html += self.renderLicense()
        html += self.renderFooter()
        html += u"</"+sectionTag+">"+lb # /#outer
        if style.hasValidConfig:
            html += style.get_extra_body() 
        html += u'<script type="text/javascript">$exe.domReady();</script></body></html>'
        html = html.encode('utf8')
        # JR: Eliminamos los atributos de las ecuaciones
        aux = re.compile("exe_math_latex=\"[^\"]*\"")
        html = aux.sub("", html)
        aux = re.compile("exe_math_size=\"[^\"]*\"")
        html = aux.sub("", html)
        #JR: Cambio el & en los enlaces del glosario
        html = html.replace("&concept", "&amp;concept")
        # Remove "resources/" from data="resources/ and the url param
        html = html.replace("video/quicktime\" data=\"resources/", "video/quicktime\" data=\"")
        html = html.replace("application/x-mplayer2\" data=\"resources/", "application/x-mplayer2\" data=\"")
        html = html.replace("audio/x-pn-realaudio-plugin\" data=\"resources/", "audio/x-pn-realaudio-plugin\" data=\"")
        html = html.replace("<param name=\"url\" value=\"resources/", "<param name=\"url\" value=\"")
        return html

    def processInternalLinks(self, html):
        """
        take care of any internal links which are in the form of:
           href="exe-node:Home:Topic:etc#Anchor"
        For this SCORM Export, go ahead and remove the link entirely,
        leaving only its text, since such links are not to be in the LMS.
        """
        return common.removeInternalLinks(html)


class Epub3Export(object):
    """
    Exports an eXe package as a epub 3 package
    The 'Hello World' of a epub 3 publication might contain files:
        mimetype
        META-INF/container.xml
        Content/HelloWorld.opf
        Content/HelloWorld.xhtml
    """
    def __init__(self, config, styleDir, filename):
        """
        Initialize
        'styleDir' is the directory from which we will copy our style sheets
        (and some gifs)
        """
        self.config       = config
        self.imagesDir    = config.webDir/"images"
        self.scriptsDir   = config.webDir/"scripts"
        self.cssDir       = config.webDir/"css"
        self.templatesDir = config.webDir/"templates"
        self.schemasDir   = config.webDir/"schemas/ims"
        self.styleDir     = Path(styleDir)
        self.filename     = Path(filename)
        self.pages        = []

    def export(self, package):
        """
        Export epub 3 package
        """
        # First do the export to a temporary directory
        outputDir = TempDirPath()

        '''
        fileDir = outputDir/"META-INF"
        fileDir.mkdir()
        fileDir = outputDir/"Content"
        fileDir.mkdir()
        '''

        metainfPages = Path(outputDir.abspath() + '/META-INF')
        #metainfPages = outputDir/'META-INF'
        metainfPages.mkdir()
        contentPages = Path(outputDir.abspath() + '/Content')
        #contentPages = outputDir/'Content'
        contentPages.mkdir()
        #print contentPages.abspath()
        # print outputDir.abspath()

        # Export the package content
        self.pages = [Epub3Page("cover", 1, package.root)]

        self.generatePages(package.root, 2)
        uniquifyNames(self.pages)

        for page in self.pages:
            page.save(contentPages)

        # Create mimetype file
        mimetypeFile = open(outputDir.abspath() + '/mimetype', "w")
        mimetypeFile.write('application/epub+zip')
        mimetypeFile.close()

        # Copy the style sheet files to the output dir
        # But not nav.css
        styleFiles = [self.styleDir/'..'/'base.css']
        styleFiles += [self.styleDir/'..'/'popup_bg.gif']
        styleFiles += [f for f in self.styleDir.files("*.css")
                if f.basename() <> "nav.css"]
        styleFiles += self.styleDir.files("*.jpg")
        styleFiles += self.styleDir.files("*.gif")
        styleFiles += self.styleDir.files("*.png")
        styleFiles += self.styleDir.files("*.js")
        styleFiles += self.styleDir.files("*.html")
        styleFiles += self.styleDir.files("*.ttf")
        styleFiles += self.styleDir.files("*.eot")
        styleFiles += self.styleDir.files("*.otf")
        styleFiles += self.styleDir.files("*.woff")
        # FIXME for now, only copy files referenced in Common Cartridge
        # this really should apply to all exports, but without a manifest
        # of the files needed by an included stylesheet it is too restrictive

        package.resourceDir.copyfiles(contentPages)

        self.styleDir.copylist(styleFiles, contentPages)
        self.scriptsDir.copylist(('common.js',), contentPages)

        # copy players for media idevices.
        hasFlowplayer     = False
        hasMagnifier      = False
        hasXspfplayer     = False
        hasGallery        = False
        hasWikipedia      = False
        isBreak           = False
        hasInstructions   = False
        hasMediaelement   = False

        for page in self.pages:
            if isBreak:
                break
            for idevice in page.node.idevices:
                if (hasFlowplayer and hasMagnifier and hasXspfplayer):
                    isBreak = True
                    break
                if not hasFlowplayer:
                    if 'flowPlayer.swf' in idevice.systemResources:
                        hasFlowplayer = True
                if not hasMagnifier:
                    if 'magnifier.swf' in idevice.systemResources:
                        hasMagnifier = True
                if not hasXspfplayer:
                    if 'xspf_player.swf' in idevice.systemResources:
                        hasXspfplayer = True

        for page in self.pages:
            if isBreak:
                break
            for idevice in page.node.idevices:
                if (hasFlowplayer and hasMagnifier and hasXspfplayer and hasGallery and hasWikipedia):
                    isBreak = True
                    break
                if not hasFlowplayer:
                    if 'flowPlayer.swf' in idevice.systemResources:
                        hasFlowplayer = True
                if not hasMagnifier:
                    if 'mojomagnify.js' in idevice.systemResources:
                        hasMagnifier = True
                if not hasXspfplayer:
                    if 'xspf_player.swf' in idevice.systemResources:
                        hasXspfplayer = True
                if not hasGallery:
                    if 'GalleryIdevice' == idevice.klass:
                        hasGallery = True
                if not hasWikipedia:
                    if 'WikipediaIdevice' == idevice.klass:
                        hasWikipedia = True
                if not hasInstructions:
                    if 'TrueFalseIdevice' == idevice.klass or 'MultichoiceIdevice' == idevice.klass or 'VerdaderofalsofpdIdevice' == idevice.klass or 'EleccionmultiplefpdIdevice' == idevice.klass:
                        hasInstructions = True
                if not hasMediaelement:
                    hasMediaelement = common.ideviceHasMediaelement(idevice)

        if hasFlowplayer:
            videofile = (self.templatesDir/'flowPlayer.swf')
            videofile.copyfile(contentPages/'flowPlayer.swf')
            controlsfile = (self.templatesDir/'flowplayer.controls.swf')
            controlsfile.copyfile(contentPages/'flowplayer.controls.swf')
        if hasMagnifier:
            videofile = (self.templatesDir/'mojomagnify.js')
            videofile.copyfile(contentPages/'mojomagnify.js')
        if hasXspfplayer:
            videofile = (self.templatesDir/'xspf_player.swf')
            videofile.copyfile(contentPages/'xspf_player.swf')
        if hasGallery:
            imageGalleryCSS = (self.cssDir/'exe_lightbox.css')
            imageGalleryCSS.copyfile(contentPages/'exe_lightbox.css')
            imageGalleryJS = (self.scriptsDir/'exe_lightbox.js')
            imageGalleryJS.copyfile(contentPages/'exe_lightbox.js')
            self.imagesDir.copylist(('exeGallery_actions.png', 'exeGallery_loading.gif'), contentPages)
        if hasWikipedia:
            wikipediaCSS = (self.cssDir/'exe_wikipedia.css')
            wikipediaCSS.copyfile(contentPages/'exe_wikipedia.css')
        if hasInstructions:
            common.copyFileIfNotInStyle('panel-amusements.png', self, contentPages)
            common.copyFileIfNotInStyle('stock-stop.png', self, contentPages)
        if hasMediaelement:
            jquery = (self.scriptsDir/'exe_jquery.js')
            jquery.copyfile(contentPages/'exe_jquery.js')
            mediaelement = (self.scriptsDir/'mediaelement')
            mediaelement.copyfiles(contentPages)
        else:
            my_style = G.application.config.styleStore.getStyle(package.style)
            if my_style.hasValidConfig:
                if my_style.get_jquery():
                    jsFile = (self.scriptsDir/'exe_jquery.js')
                    jsFile.copyfile(contentPages/'exe_jquery.js')

        if package.license == "GNU Free Documentation License":
            # include a copy of the GNU Free Documentation Licence
            (self.templatesDir/'fdl.html').copyfile(contentPages/'fdl.html')

        # Create the nav.xhtml file
        container = NavEpub3(self.pages, contentPages)
        container.save()

        # Create the publication file
        publication = PublicationEpub3(self.config, contentPages, package, self.pages)
        publication.save("iteexe_project.opf")

        # Create the container file
        container = ContainerEpub3(metainfPages)
        container.save("container.xml")

        # Zip it up!
        self.filename.safeSave(self.doZip, _(u'EXPORT FAILED!\nLast succesful export is %s.'), outputDir)
        # Clean up the temporary dir

        outputDir.rmtree()

    def doZip(self, fileObj, outputDir):
        """
        Actually does the zipping of the file. Called by 'Path.safeSave'
        """
        zipped = ZipFile(fileObj, "w")

        mimetype = outputDir/"mimetype"
        zipped.write(mimetype, "mimetype", ZIP_STORED)

        for epubFile in outputDir.walkfiles():
            if epubFile.basename() == 'mimetype':
                continue
            relativePath = epubFile.basename()
            parentdir = epubFile.splitpath()[0]
            while (outputDir.basename() != parentdir.basename()):
                relativePath = parentdir.basename()/relativePath
                parentdir = parentdir.splitpath()[0]

            zipped.write(epubFile,
                             relativePath.encode('utf8'),
                             compress_type=ZIP_DEFLATED)
        zipped.close()

    def generatePages(self, node, depth):
        """
        Recursive function for exporting a node.
        'node' is the node that we are making a page for
        'depth' is the number of ancestors that the page has +1 (ie. root is 1)
        """
        for child in node.children:
            pageName = child.titleShort.lower().replace(" ", u"_")
            pageName = re.sub(r"\W", "", pageName)
            if not pageName:
                pageName = u"__"

            page = Epub3Page(pageName, depth, child)

            self.pages.append(page)
            self.generatePages(child, depth + 1)
