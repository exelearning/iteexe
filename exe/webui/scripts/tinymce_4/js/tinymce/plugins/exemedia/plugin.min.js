/**
 * plugin.min.js
 * "Title and Attribution" tab, player options and backward compatibility by Ignacio Gros (http://gros.es/)
 * Released under Attribution 4.0 International License.
 * License: http://creativecommons.org/licenses/by/4.0/
 * The rest is mostly a copy of TinyMCE's plugins\media\plugin.js, released under LGPL License (Copyright (c) 1999-2015 Ephox Corp. All rights reserved) 
 */ 

// After editing with TinyMCE 4 a content with media files created in TinyMCE 3 there will be some changes:
// width and height will be removed from the AUDIO tags
// QuickTime: 
	// Just <a href="*.mov">*.mov</a>
	// Instead of <param name="flv_src" value="*.mov" /><a href="*.mov">*.mov</a>

tinymce.PluginManager.add('exemedia', function(editor, url) {	
	
	var recommendedFormats = "mp4, mp3, webm, ogg/ogv, mpeg, swf, flv";
	var currentFileIsQuickTime = false; // QuickTime can be edited
	
	var urlPatterns = [
		{regex: /youtu\.be\/([\w\-.]+)/, type: 'iframe', w: 560, h: 314, url: 'https://www.youtube.com/embed/$1', allowFullscreen: true},
		{regex: /youtube\.com(.+)v=([^&]+)/, type: 'iframe', w: 560, h: 314, url: 'https://www.youtube.com/embed/$2', allowFullscreen: true},
		{regex: /youtube.com\/embed\/([a-z0-9\-_]+(?:\?.+)?)/i, type: 'iframe', w: 560, h: 314, url: 'https://www.youtube.com/embed/$1', allowFullscreen: true},
		{regex: /vimeo\.com\/([0-9]+)/, type: 'iframe', w: 425, h: 350, url: 'https://player.vimeo.com/video/$1?title=0&byline=0&portrait=0&color=8dc7dc', allowfullscreen: true},
		{regex: /vimeo\.com\/(.*)\/([0-9]+)/, type: "iframe", w: 425, h: 350, url: "https://player.vimeo.com/video/$2?title=0&amp;byline=0", allowfullscreen: true},
		{regex: /maps\.google\.([a-z]{2,3})\/maps\/(.+)msid=(.+)/, type: 'iframe', w: 425, h: 350, url: 'https://maps.google.com/maps/ms?msid=$2&output=embed"', allowFullscreen: false},
		{regex: /dailymotion\.com\/video\/([^_]+)/, type: 'iframe', w: 480, h: 270, url: 'https://www.dailymotion.com/embed/video/$1', allowFullscreen: true}
	];

	var embedChange = (tinymce.Env.ie && tinymce.Env.ie <= 8) ? 'onChange' : 'onInput';
	
	function parse_media_html_attributes(c) {

		/* 
			This function reorders the HTML attributes.
			eXeLearning expects the code in a certain order (see field.py). That should be reviewed...

			Example:
				<object type="application/x-shockwave-flash" data="...
				instead of
				<object data="..." type="application/x-shockwave-flash"

			The HTML format expected by eXeLearning is at the end of the function (swf, mp3, flv and video).
		*/

		var new_c = '';
		
		if (c.indexOf("<object ")!=-1) {
			
			var c_parts = c.split("<object ");
			
			for (i=0;i<c_parts.length;i++) {
				
				var c_parts_2 = c_parts[i].split(">");
				
				for (z=0;z<c_parts_2.length;z++) {
				
					// Replacement:
					if (c_parts_2[z].indexOf('type="application/x-shockwave-flash"')!=-1 || c_parts_2[z].indexOf('type="video/quicktime"')!=-1 || c_parts_2[z].indexOf('type="application/x-mplayer2"')!=-1 || c_parts_2[z].indexOf('type="audio/x-pn-realaudio-plugin"')!=-1) {
						
						var o_attrs = c_parts_2[z].split(" ");
						var o_type = "";
						var o_data = "";
						var o_other_attrs = "";
						var o_attrs_reordered = "";
						for (y=0;y<o_attrs.length;y++) {
							
							// new_c += o_attrs[y];
							// if (y<(o_attrs.length-1)) new_c+=" ";
							if (o_attrs[y].indexOf('type=')!=-1) o_type = o_attrs[y]+" ";
							else if (o_attrs[y].indexOf('data=')!=-1) {
								var current_data = o_attrs[y];
								// Check if it is an flv:
								var current_file_extension = current_data.substring(current_data.length - 4, current_data.length-1).toLowerCase();
								if (current_file_extension=="flv") {
									// We replace data="path_to_flv.flv" by data="../templates/flowPlayer.swf"
									o_data = 'data="../templates/flowPlayer.swf" ';							
								} else {
									o_data = o_attrs[y]+" ";
								}
								
							}
							else o_other_attrs += o_attrs[y]+" ";
							
						}
						o_attrs_reordered = o_type+o_data+o_other_attrs;
						// Remove the last space
						o_attrs_reordered = o_attrs_reordered.replace(/\s+\S*$/, "")
						new_c += o_attrs_reordered;				
						
					} else {
					
						// Check if it is flv to change the flashvars format:
						
						var is_flv_src = false;
						
						if(c_parts_2[z].indexOf('<param name="flv_src" value="')==0) {
						
							is_flv_src = true;
							var my_video_url = c_parts[i].split("config={'playlist': [ { 'url': '");
							if (my_video_url.length>1) {
								my_video_url = my_video_url[1];
								my_video_url = my_video_url.split("'");
								new_c += '<param name="flv_src" value="'+my_video_url[0]+'" />';
							}
							
						} else if(c_parts_2[z].indexOf('<param name="flashvars" value="')==0) {
							var flashvars = c_parts_2[z].replace('<param name="flashvars" value="','').replace('"','');
							// Input: url=path_to_file.flv&amp;poster=/.../
							// Output: config={'playlist': [ { 'url': 'path_to_file.flv', 'autoPlay': false, 'autoBuffering': true } ] }
							var file_url = flashvars.replace('url=','');
							file_url = file_url.split('&')[0];
							
							// flv file:
							if (file_url.split('.').pop().toLowerCase()=='flv') {
								var new_flashvars = "config={\'playlist\': [ { \'url\': \'"+file_url+"\', \'autoPlay\': false, \'autoBuffering\': true } ] }";
								new_c += '<param name="flashvars" value="'+new_flashvars+'" /';	
							} else {
								// No replacement
								new_c += c_parts_2[z];
								// This is done by changing line data.params.src = flashPlayer; by this one data.params.src = video_src; in editor_plugin.js
								// new_c = new_c.replace('<param name="src" value="../templates/flowPlayer.swf" />','<param name="src" value="/previews/path.flv" />');							
							}
						
						} else {
							// No params:
							new_c += c_parts_2[z];
						}
						
					}
					
					if (z<(c_parts_2.length-1) && !is_flv_src) new_c+=">";
					
				}
				
				if (i<(c_parts.length-1)) new_c+="<object ";

			}
			
			// Required for flv:
			var str3 = '"http://'+window.location.host+'/templates/flowPlayer.swf';
			var re3 = new RegExp(str3, 'g');
			new_c= new_c.replace(re3, '"../templates/flowPlayer.swf');		
			
			// Required for mp3:
			// new_c = new_c.replace( "http://127.0.0.1:51235/templates/xspf_player.swf", "../templates/xspf_player.swf" ); 
			var str1 = '"http://'+window.location.host+'/templates/xspf_player.swf';
			var re1 = new RegExp(str1, 'g');
			new_c= new_c.replace(re1, '"../templates/xspf_player.swf');		

			// Required for al media:
			
			// Remove http://127.0.0.1:51235/packageName/
			var str3 = "http://"+window.location.host+"/"+encodeURIComponent(exe_package_name)+"/";
			var re3 = new RegExp(str3, "g");
			new_c= new_c.replace(re3, "");      
			
			// new_c = new_c.replace( /\http:\/\/127.0.0.1:51235/g, "" ); 
			var str2 = "http://"+window.location.host;
			var re2 = new RegExp(str2, "g");
			new_c= new_c.replace(re2, "");	

		} else {

			// No object tags
			new_c = c;

		}
		
		// HTML format:
		
		/* 
		
		// SWF code:
		var swf_code = '<object type="application/x-shockwave-flash" data="/previews/path.swf" width="" height="">';
			swf_code += '<param name="src" value="/previews/path.swf" />';
			swf_code += '</object>';
		
		// FLV code:
		var flv_code = '<object type="application/x-shockwave-flash" data="../templates/flowPlayer.swf" width="" height="">';
			flv_code += '<param name="src" value="/previews/path.flv" />';
			flv_code += '<param name="flashvars" value="config={\'playlist\': [ { \'url\': \'/previews/path.flv\', \'autoPlay\': false, \'autoBuffering\': true } ] }" />';
			flv_code += '<param name="exe_flv" value="/previews/path.flv" />';	
			flv_code += '</object>';
			
		// Old MP3 code (we now use AUDIO):
		var mp3_code = '<object type="application/x-shockwave-flash" data="/previews/path.mp3" width="" height="">';
			mp3_code += '<param name="src" value="/previews/path.mp3" />';
			mp3_code += '<param name="exe_mp3" value="/previews/path.mp3" />';
			mp3_code += '</object>';	
			
		// HTML5 video code:
		var video_code = '<video src="resources/file..." width="" height="" preload="none">';
			video_code += '<a href="/previews/path...">/previews/C__Users_Ignacio_Desktop_transfer_paraSubir_video_audio_video.flv</a>';
			video_code += '</video>';
			
		// QuickTime code:
		video_code = '<object type="video/quicktime" data="/previews/path..." width="" height="">';
			video_code += '<param name="controller" value="true" />';
			video_code += '<param name="autoplay" value="false" />';
			video_code += '<a href="/previews/path...">/previews/path...</a>';
			video_code += '</object>';
		
		Important: common.js adds the classid attribute to the object tag.
		It would be better to do it without JS, but doing it and keep the video edition working is really complex and doing it when exporting will change HTML defined be the user and may cause other problems.
		
		*/
		
		// iframes: Replace all frameborder="0" with style="border:0" in HTML5
		if (typeof(exe_export_format)!='undefined' && exe_export_format=="html5" && new_c.indexOf("<iframe ")!=-1) {
			var c2 = '';
			var c_parts = new_c.split("<iframe ");
			for (i=0;i<c_parts.length;i++) {
				var c_parts_2 = c_parts[i].split(">");
				for (z=0;z<c_parts_2.length;z++) {				
					var p = c_parts_2[z];
					if ( p.indexOf(' style="')==-1 && p.indexOf('width="')==0 && (p.substr(p.length-15)=='frameborder="0"' || p.substr(p.length-34)=='frameborder="0" allowfullscreen=""') ) {
						p = p.replace(' frameborder="0"',' style="border:0"');
					}
					c2 += p;
					if (z<c_parts_2.length-1) c2+=">";
				}
				if (i<(c_parts.length-1)) c2+="<iframe ";
			}
			new_c = c2;
		}
		
		// Remove the data-mce-fragment attribute (see iteexe's issue #229)
		var hasTinyMCEattr = false;
		var div = jQuery("<div></div>");
			div.html(new_c);
		jQuery("video,audio",div).each(function(){
			if (jQuery(this)[0].hasAttribute("data-mce-fragment")) {
				hasTinyMCEattr = true;
				jQuery(this).removeAttr("data-mce-fragment");
			}
		});
		if (hasTinyMCEattr) new_c = div.html();
		
		return new_c;
		
	} // parse_media_html_attributes

	function guessMime(url) {
		url = url.toLowerCase();

		if (url.indexOf('.mp3') != -1) {
			return 'audio/mpeg';
		}

		if (url.indexOf('.wav') != -1) {
			return 'audio/wav';
		}

		if (url.indexOf('.mp4') != -1) {
			return 'video/mp4';
		}

		if (url.indexOf('.webm') != -1) {
			return 'video/webm';
		}

		if (url.indexOf('.ogg') != -1) {
			// OGG can be audio or video, but the the user can change that using the #type listbox
			return 'video/ogg';
		}

		if (url.indexOf('.swf') != -1) {
			return 'application/x-shockwave-flash';
		}

		return '';
	}

	function getVideoScriptMatch(src) {
		var prefixes = editor.settings.media_scripts;

		if (prefixes) {
			for (var i = 0; i < prefixes.length; i++) {
				if (src.indexOf(prefixes[i].filter) !== -1) {
					return prefixes[i];
				}
			}
		}
	}
	
	// Hide or show the Custom license field 
	function toggleCustomLicense(value) {
		
		var customLicense = jQuery("#customcaptionlicense");
		var customLicenseLabel = jQuery("#customcaptionlicense-l");
		
		if (value!='custom') {
			customLicense.val("").prop("disabled","disabled").css("opacity",0.2);
			customLicenseLabel.css("opacity",0.2);						
		} else {
			customLicense.prop("disabled",false).css("opacity",1);
			customLicenseLabel.css("opacity",1);						
		}
		
	}

	function showDialog() {
		
		// Is in figure?
		var elm = editor.selection.getNode();
		var figure = editor.dom.getParents(elm, '.exe-figure');
		var isIframe = false;
		if (elm.nodeName=="SPAN" && elm.className && elm.className.indexOf("mce-preview-object")!=-1) isIframe = true;
		if (figure.length==1 && elm.nodeName!="IMG" && !isIframe) {
			var figureHTML = figure[0].innerHTML;
			// When it's a figure containing an media element you have to select that element to open the dialog
			// Otherwise the "Title and Attribution" panel will not load the previous values
			if (figureHTML.indexOf('<iframe')!=-1 || figureHTML.indexOf('<img data-mc')!=-1) {
				editor.windowManager.alert(_('Please select the media file to edit it'));
				return false;				
			}
		}
		
		var win, width, height, data;

		function recalcSize(e) {
			var widthCtrl, heightCtrl, newWidth, newHeight;

			widthCtrl = win.find('#width')[0];
			heightCtrl = win.find('#height')[0];

			newWidth = widthCtrl.value();
			newHeight = heightCtrl.value();

			if (win.find('#constrain')[0].checked() && width && height && newWidth && newHeight) {
				if (e.control == widthCtrl) {
					newHeight = Math.round((newWidth / width) * newHeight);

					if (!isNaN(newHeight)) {
						heightCtrl.value(newHeight);
					}
				} else {
					newWidth = Math.round((newHeight / height) * newWidth);

					if (!isNaN(newWidth)) {
						widthCtrl.value(newWidth);
					}
				}
			}

			width = newWidth;
			height = newHeight;
		}

		data = getData(editor.selection.getNode());
		width = data.width;
		height = data.height;

		var embedTextBox = {
			id: 'mcemediasource',
			type: 'textbox',
			flex: 1,
			name: 'embed',
			value: getSource(),
			multiline: true,
			label: 'Source'
		};

		function updateValueOnChange() {
			data = htmlToData(this.value());
			this.parent().parent().fromJSON(data);
		}
		
		function removeMediaElementClass(c){
			if (!c) return "";
			var parts = c.split(" ");
			var res = ""; 
			var arr = [];
			for (var i=0;i<parts.length;i++) {
				var part = parts[i];
				if (part!="" && part!="mediaelement") {
					arr.push(part);
				}
			}
			for (var z=0;z<arr.length;z++) {
				res += arr[z];
				if (z<(arr.length-1)) res += " ";
			}
			if (res!="") c = res;
			if (c=="mediaelement") c = "";
			return c;
		}		
		
		function getAttributionTab() {
			return [
						{
							label: _("Header"),
							name: 'imageheader',
							id: 'imageheader',
							type: 'textbox'
						},
						{
							type: 'fieldset',
							title: _('Footer caption'),
							style: 'margin-top:5px',
							items: [
								{
									label: _("Title"),
									name: 'imagetitle',
									id: 'imagetitle',
									type: 'textbox'
								},
								{
									label: _("Title Link"),
									name: 'imagetitlelink',
									id: 'imagetitlelink',
									type: 'textbox'
								},
								{
									label: _("Source/Author"),
									name: 'authorname',
									id: 'authorname',
									type: 'textbox'
								},
								{
									label: _("Source/Author Link"),
									name: 'authornamelink',
									id: 'authornamelink',
									type: 'textbox'
								},
								{
									name: 'captionlicense',
									id: 'captionlicense',
									type: 'listbox',
									label: _("License"),
									values: [
										{text: _("Choose a license..."), value: ''},
										{text: _("Public Domain"), value: 'pd'},
										{text: "GNU/GPL", value: 'gnu-gpl'},
										{text: "GFDL", value: 'gfdl'},
										{text: "Creative Commons ("+_("Public Domain")+")", value: 'CC0'},
										{text: "Creative Commons BY", value: 'CC-BY'},
										{text: "Creative Commons BY-SA", value: 'CC-BY-SA'},
										{text: "Creative Commons BY-ND", value: 'CC-BY-ND'},
										{text: "Creative Commons BY-NC", value: 'CC-BY-NC'},
										{text: "Creative Commons BY-NC-SA", value: 'CC-BY-NC-SA'},
										{text: "Creative Commons BY-NC-ND", value: 'CC-BY-NC-ND'},
										{text: "Copyright ("+_("All Rights Reserved")+")", value: 'copyright'},
										{text: _("Custom license"), value: 'custom'}
									],
									onselect : function(){
										toggleCustomLicense(this.value());
									}
								},
								{
									name: 'customcaptionlicense',
									id: 'customcaptionlicense',
									type: 'textbox',
									label: _("Custom license")
								}							
							]
						}
					]
		}

		embedTextBox[embedChange] = updateValueOnChange;

		win = editor.windowManager.open({
			title: _("Insert/Edit Embedded Media"),
			data: data,
			bodyType: 'tabpanel',
			body: [
				{
					title: _('General'),
					type: "form",
					onShowTab: function() {
						data = htmlToData(this.next().find('#embed').value());
						this.fromJSON(data);
					},
					items: [
						{
							type: 'listbox',
							minWidth: 150,
							name: 'type',
							id: 'type',
							label: _('Type'),
							'values': [
								{text: _('Detect automatically'), value: ''},
								{text: _('Video'), value: 'video'},
								{text: _('Audio'), value: 'audio'},
								{text: _('iframe'), value: 'iframe'}
							],
							onselect: function(){
								data.type = this.value();
								win.find('#embed').value(dataToHtml(win.toJSON(),false)); // false isDataEmbed (we want the code to be updated)
							}
						},					
						{
							name: 'source1',
							type: 'filepicker',
							filetype: 'media',
							size: 40,
							autofocus: true,
							label: _('Source'),
							onchange: function(e) {
								tinymce.each(e.meta, function(value, key) {
									win.find('#' + key).value(value);
								});
							}
						},					
						{
							type: 'container',
							label: _('Dimensions'),
							layout: 'flex',
							align: 'center',
							spacing: 5,
							items: [
								{name: 'width', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Width'},
								{type: 'label', text: 'x'},
								{name: 'height', type: 'textbox', maxLength: 5, size: 3, onchange: recalcSize, ariaLabel: 'Height'},
								{name: 'constrain', type: 'checkbox', checked: true, text: 'Constrain proportions'}
							]
						},
						{
							type: 'container',
							label: _('Options'),
							layout: 'flex',
							direction: 'column',
							spacing: 5,
							items: [
								{name: 'jsplayer', type: 'checkbox', checked: true, text: _("Use JavaScript player")},
								{name: 'usecontrols', type: 'checkbox', checked: true, text: _("Use Controls")},
								{name: 'autoplay', type: 'checkbox', checked: false, text: _("Use Autoplay"),
									onchange: function(){
										var v = 'hidden';
										if (this.state.get("checked")) v = 'visible';
										$("#muted-wrapper").css("visibility",v);
									}								
								},
								{name: 'muted', type: 'checkbox', checked: false, text: _("Mute Autoplay Video"),
									id: 'muted-wrapper', 
									style: 'visibility:hidden'
								}
							]
						}						
					]
				},

				{
					title: _('Code'),
					type: "container",
					layout: 'flex',
					direction: 'column',
					align: 'stretch',
					padding: 10,
					spacing: 10,
					onShowTab: function() {
						this.find('#embed').value(dataToHtml(this.parent().toJSON()));
					},
					items: [
						{
							type: 'label',
							text: _('Paste your embed code below:'),
							forId: 'mcemediasource'
						},
						embedTextBox
					]
				},
				
				{
					title: _("Title and Attribution"),
					type: 'form',
					pack: 'start',
					items: getAttributionTab()
				},
				
				{
					title: _('Attributes'),
					type: 'form',
					pack: 'start',
					items: [
						{ type: 'textbox', name: 'id', size: 40, label: _('ID'), value: data.id || "", onkeyup: function(){
							var val = this.value();
								val = val.replace(/ /g,'');
							if (val.length>0) {
								var last = val.slice(-1);
								if (val.length==1) {
									if(!last.match(/^[A-Za-z]+$/)) val = val.substring(0, val.length-1);
								} else {
									if(!last.match(/^[a-z0-9]+$/i) && last!="_" && last!="-") val = val.substring(0, val.length-1);
								}
							}
							this.value(val);
						} },
						{ type: 'textbox', name: 'cssClass', size: 40, label: _('CSS class'), value: removeMediaElementClass(data.class) || "" },
						{ type: 'textbox', name: 'cssStyle', size: 40, label: _('Style'), value: data.style || "" }					
					]
				}
				
			],
			
			onSubmit: function() {
				
				// The Source is required
				var source1 = this.find("#source1")[0].value();
				if (source1 == "") {
					editor.windowManager.alert(_('Please select the Source'));
					return false;
				} else if (source1.indexOf("http:")==0) {
					// Do not mix http and https when using iframes...
					editor.windowManager.confirm(
						_('Remember that HTTP pages cannot be included into HTTPS websites.'),
						function(s){
							if (s) {
								submitForm(win);
							}
						}
					);
					return false;
				}
				
				// Videos with autoplay should have the muted attribute
				if (win.find("#autoplay")[0].checked()) {
					var isVideo = dataToHtml(win.toJSON()).indexOf("<video ")==0;
					if (isVideo) {
						if (!win.find("#muted")[0].checked()) {
							editor.windowManager.confirm(
								_('Â¿Mute Autoplay Video (recommended)?'),
								function(s){
									if (s) {
										win.find("#muted").checked(true);
									}
									submitForm(win);
								}
							);					
							return false;
						}
					}
				}
				
				// Update the data
				data.source1 = source1;
				
				var isQuickTime = false;
				source1 = source1.split("/");
				source1 = source1[source1.length-1];
				if (source1.indexOf(".mov")!=-1) {
					isQuickTime = true;
				}
				
				// Update the HTML code (not for QuickTime, or the OBJECT tag will be replaced by VIDEO)
				if (!isQuickTime) this.find('#embed').value(dataToHtml(this.toJSON(),false));
				
				submitForm(this);	
				return false;
				
			}
			
		});
		
		getPreviousValues(win);
		
	}
	
	function addAttributes(tmpWrapper,html,win){
		
		// Get the tag (AUDIO, VIDEO, IFRAME, OBJECT or SCRIPT)
		var tag = $("audio",tmpWrapper);
		if (tag.length!=1) tag = $("video",tmpWrapper);
		if (tag.length!=1) tag = $("iframe",tmpWrapper);
		if (tag.length!=1) tag = $("object",tmpWrapper);
		if (tag.length!=1) tag = $("script",tmpWrapper);
		if (tag.length!=1) return html;
		
		// Add or remove the ID
		var id = win.find("#id").value();
		if (id=="") tag.removeAttr("id");
		else tag.attr("id",id);
		
		// Add or remove the CSS class
		var css = win.find("#cssClass").value();
		if (css=="") tag.removeAttr("class");
		else tag.attr("class",css);
		
		// Add or remove the style attribute
		var style = win.find("#cssStyle").value();
		if (style=="") tag.removeAttr("style");
		else tag.attr("style",style);	
		
		return tmpWrapper.html();
	}

	function submitForm(win) {
		
		var beforeObjects, afterObjects, i, y;

		beforeObjects = editor.dom.select('img[data-mce-object]');
		
		var html = dataToHtml(win.toJSON());
		
		// We replace autoplay so the video/audio does not play when we put it in #tmpWrapper
		html = html.replace('autoplay="autoplay"','exe-autoplay="exe-autoplay"')
		
		var tmpWrapper = jQuery("#tmpWrapper");
		if (tmpWrapper.length==0) {
			tmpWrapper = jQuery('<div id="tmpWrapper" style="display:none">'+html+'</div>');
			jQuery('body').append(tmpWrapper);
		} else {
			tmpWrapper.html(html);
		}
		
		// Add attributes
		addAttributes(tmpWrapper,html,win);
		
		var tmpTag = 'video'
		if (html.indexOf('<audio')==0) tmpTag = 'audio';
		var tmpMedia = jQuery(tmpTag,tmpWrapper);
		
		// JavaScript Player
		if (win.find("#jsplayer")[0].checked()) {
			tmpMedia.removeClass("mediaelement");
			var c = tmpMedia.attr("class");
			// The mediaelement class has to be at the start (see ideviceHasMediaelement in common.py)
			if (c && c!="") tmpMedia.attr("class","mediaelement "+c);
			else tmpMedia.addClass("mediaelement");
		} else {
			tmpMedia.removeClass("mediaelement");
		}
		if (tmpMedia.attr("class")=="") tmpMedia.removeAttr("class");
		
		// Controls
		if (win.find("#usecontrols")[0].checked()) {
			tmpMedia.attr("controls","controls");
		} else {
			tmpMedia.removeAttr("controls");
		}

		// Auto-play
		if (win.find("#autoplay")[0].checked()) {
			tmpMedia.attr("exe-autoplay","exe-autoplay");
		} else {
			tmpMedia.removeAttr("exe-autoplay");
		}

		// Default dimensions
		var mediaWidth = win.find("#width").value();
		var mediaHeight = win.find("#height").value();
		if (tmpTag == 'video') {
			if (mediaWidth == "") mediaWidth = 320;
			if (mediaHeight == "") mediaHeight = 240;
		} else {
			// HTML5 AUDIO should have no width or height;
			if (mediaWidth == "") mediaWidth = '';
			if (mediaHeight == "") mediaHeight = '';
		}
		tmpMedia.attr("width",mediaWidth);
		tmpMedia.attr("height",mediaHeight);
		
		html = tmpWrapper.html();
		html = html.replace('exe-autoplay="exe-autoplay"','autoplay="autoplay"');
		
		// Title and Attribution
		var imageHeader = win.find("#imageheader")[0].value();
		var imageTitle = win.find("#imagetitle")[0].value();
		var imageTitleLink = win.find("#imagetitlelink")[0].value();
		var authorName = win.find("#authorname")[0].value();
		var authorNameLink = win.find("#authornamelink")[0].value();
		var captionLicense = win.find("#captionlicense")[0].value();
		
		// Check some formats using OBJECT
		
		var selectedFile = win.find("#source1")[0].value();
		var selectedFileExt = selectedFile.substring(selectedFile.length-3,selectedFile.length).toLowerCase();		
		
		// OGG
		if (selectedFileExt=="ogg" && win.find("#type").value()=="") {
			// It can be video or audio
			editor.windowManager.alert(
				_('This format (%) is valid for audio and video.').replace("%","ogg") + '\n' +
				_('Cannot detect automatically. Please choose the right type.')
			);			
			return false;
		}
		
		// QuickTime
		else if (selectedFileExt=="mov") {
			
			var movWidth = win.find("#width")[0].value();
			if (movWidth=="") movWidth = mediaWidth;
			var movHeight = win.find("#height")[0].value();
			if (movHeight=="") movHeight = mediaHeight;
            if (document.getElementById('mcemediasource').value.toLowerCase().indexOf("<object")!=-1) {
				
				// QuickTime can be edited, but we recommend using other formats
				editor.windowManager.alert(_('Successfully updated, but please convert the video to another format:') + ' webm, mp4, ogg...');
				html = '<object width="'+mediaWidth+'" height="'+mediaHeight+'" type="video/quicktime" data="'+selectedFile+'"><param name="controller" value="true" /><param name="autoplay" value="false" /><param name="src" value="'+selectedFile+'" /><a href="'+selectedFile+'">'+selectedFileExt+'</a></object>';
				
			} else {
				
				// No new QuickTime files, just the old ones
				editor.windowManager.alert(
					_('Selected format: ') + selectedFileExt+'. ' + 
					_('Please use any of these formats or provide a link to the file itself: ') + recommendedFormats + '.'
				);
				return;
				
			}
			
		} else if (selectedFileExt=="wmv" || selectedFileExt=="wma" || selectedFileExt=="ram") {
			
			// WMV, WMA and RAM are not allowed
			editor.windowManager.alert(
				_('Selected format: ') + selectedFileExt+'. ' + 
				_('Please use any of these formats or provide a link to the file itself:') + recommendedFormats + '.'
			);
			return;
			
		} else if (currentFileIsQuickTime) {
			
			if (selectedFileExt=='mp3') {
				
				// It was a QuickTime file, but the Source has changed (it's an mp3)
				html = '<audio class="mediaelement" src="'+selectedFile+'" controls="controls">';
					html += '<a href="'+selectedFile+'">'+selectedFile.replace("resources/","")+'</a>';
				html += '</audio>';
				
			} else {
				
				// It was a QuickTime file, but the Source has changed
				html = '<video width="'+mediaWidth+'" height="'+mediaHeight+'" class="mediaelement" controls="controls">';
					html += '<a href="'+selectedFile+'">'+selectedFile.replace("resources/","")+'</a>';
					html += '<source src="'+selectedFile+'" />';
				html += '</video>';
				
			}		

		}
		
		// Videos with autoplay should have the muted attribute
		if (html.indexOf("<video ")==0) {
			if (win.find("#muted")[0].checked() && html.indexOf(" muted")==-1) {
				html = html.replace(' autoplay="autoplay"',' autoplay="autoplay" muted="muted"');
			}
		}

		// Add the wrapper if needed
		if (imageHeader!="" || imageTitle!="" || imageTitleLink!="" || authorName!="" || authorNameLink!="" || captionLicense!="") {
			
			var hText = "";
			var cText = "";
			var license = "";
			
			var figureTag = "div";
			var headerFigcaptionTag = "div";
			var footerFigcaptionTag = "div";
			if (typeof(exe_export_format)!='undefined' && exe_export_format=="html5") {
				figureTag = "figure";
				if (imageTitle=="" && imageTitleLink=="" && authorName=="" && authorNameLink=="" && captionLicense=="") headerFigcaptionTag = "figcaption";
				footerFigcaptionTag = "figcaption";
			}                
			
			// Header
			if (imageHeader!="") {
				hText = "<"+headerFigcaptionTag+" class='figcaption header'><strong>"+imageHeader+"</strong></"+headerFigcaptionTag+">";
			}
			
			// Author and link
			if (authorName!="") {
				if (authorNameLink!="") {
					cText+="<a href='"+authorNameLink+"' target='_blank' class='author'>"+authorName+"</a>";
				} else {
					cText+="<span class='author'>"+authorName+"</span>";
				}
			} else {
				if (authorNameLink!="") {
					cText+="<a href='"+authorNameLink+"' target='_blank' class='author'>"+authorNameLink+"</a>";
				}
			}
			
			// Title and link
			if (imageTitle!="") {
				if (cText!="") cText+=". ";
				if (imageTitleLink!="") {
					cText+="<a href='"+imageTitleLink+"' target='_blank' class='title'><em>"+imageTitle+"</em></a>";
				} else {
					cText+="<span class='title'><em>"+imageTitle+"</em></span>";
				}
			} else {
				if (imageTitleLink!="") {
					if (cText!="") cText+=" - ";
					cText+="<a href='"+imageTitleLink+"' target='_blank' class='title'><em>"+imageTitleLink+"</em></a>";
				}
			}
			
			// License:
			var licenseLang = "en";
			var ccLink = "http://creativecommons.org/licenses/";
			var w = window.opener;
			if (!w) w = window.parent;
			if (w && w.document.getElementsByTagName) {
				var lang = w.document.getElementsByTagName("HTML")[0].lang;
				if (lang && lang != "") licenseLang = lang;
				if (lang!="en") ccLink += "?lang="+lang;
			}  
			
			if (captionLicense!="") {
				
				if (captionLicense=="custom") {
					license = win.find("#customcaptionlicense")[0].value();
				} else if (captionLicense=="pd") {
					license = "<span>"+_("Public Domain")+"</span>";
				} else if (captionLicense=="gnu-gpl") {
					license = "<a href='http://www.gnu.org/licenses/gpl.html' rel='license nofollow' target='_blank'>GNU/GPL</a>";
				} else if (captionLicense=="gfdl") {
					license = "<a href='https://www.gnu.org/licenses/fdl-1.3.html' rel='license nofollow' target='_blank'>GFDL</a>";
				} else if (captionLicense=="CC0") {
					license = "<a href='http://creativecommons.org/publicdomain/zero/1.0/deed."+licenseLang+"' rel='license nofollow' target='_blank' title='Creative Commons (CC0)'>CC0</a>";
				} else if (captionLicense=="copyright") {
					license = "<span>"+_("All Rights Reserved")+"</span>";
				} else {
					license = "<a href='"+ccLink+"' rel='license nofollow' target='_blank' title='"+captionLicense.replace("CC-","Creative Commons ")+"'>"+captionLicense.replace("CC-","CC ")+"</a>";
				}

				if (license!="") {
					if (captionLicense=="custom") license = '<span class="custom-license">'+license+'</span>';
					if (cText!="") {
						license = ' <span class="license"><span class="sep">(</span>'+license+'<span class="sep">)</span></span>';
					} else {
						license = '<span class="license"><span class="tit">'+_("License")+": </span>"+license+"</span>";
					}
				}
				
			}
			
			var defaultPos = "position-center";
			// Use the "exealign" plugin to control the alignment
			// if (imageAlignment=="left" || imageAlignment=="right") defaultPos = "float-"+imageAlignment;
			var cssClass = "exe-figure exe-media "+defaultPos;
			if (captionLicense!="") cssClass += " license-"+captionLicense;
			
			// Update the media width (data.width is not available)
			if (html.indexOf(' width="')!=-1) {
				var newMediaWidth = html.split(' width="')[1].split('"')[0];
				if (!isNaN(newMediaWidth)) mediaWidth = newMediaWidth;
			}
			if (mediaWidth=="") mediaWidth = 300; // audio
			var extraStyle="width:"+mediaWidth+"px;";

			var fText = "";
			if (cText!="" || license!="") fText = "<"+footerFigcaptionTag+" class='figcaption'>"+cText+license+"</"+footerFigcaptionTag+">";

			html = "<"+figureTag+" class='"+cssClass+"' style='"+extraStyle+"'>"+hText+html+fText+"</"+figureTag+">";
			
		}					
		
		// Is in figure?
		var elm = editor.selection.getNode();
		var figure = editor.dom.getParents(elm, '.exe-figure');	
		if (figure.length>0) {
			
			// Remove the previous figure/s
			// We have to add a tmp string, otherwise we'll get an error when inserting the content (issue #214)
			jQuery(figure).before("%exemedia_tmp_figure%");
			editor.dom.remove(figure);
			
			// If the editor is empty we have to insert the content like this
			// Otherwise no content will be added (the editor will remain empty)
			if (editor.getContent()=="") {
				
				editor.setContent(html+"<br />");
				editor.windowManager.close();
				return;
				
			} else {
				
				// See issue #214
				// editor.execCommand('mceInsertContent', false, html);
				// Replace the tmp string with the new code
				editor.setContent(editor.getContent().replace("%exemedia_tmp_figure%",html));
				
			}
			
		} else {
			
			// New figure (we add a new paragraph after it so it's easier to keep writing)
			html += "<br />";
			editor.execCommand('mceInsertContent', false, html);
			
		}
		
		editor.windowManager.close();
		
		afterObjects = editor.dom.select('img[data-mce-object]');

		// Find new image placeholder so we can select it
		for (i = 0; i < beforeObjects.length; i++) {
			for (y = afterObjects.length - 1; y >= 0; y--) {
				if (beforeObjects[i] == afterObjects[y]) {
					afterObjects.splice(y, 1);
				}
			}
		}
		
		editor.selection.select(afterObjects[0]);
		editor.nodeChanged();
		
	}
	
	function getPreviousValues(win){
		
		var sourceField = win.find("#source1")[0];
		var originalSource = sourceField.value();
		
		// Remove spaces in ID
		var id_field = win.find("#id");
		id_field.value(id_field.value().replace(/ /g,''));
		
		// Hide the Custom license field
		toggleCustomLicense("");
		
		var elm = editor.selection.getNode();
		
		if (elm.className.indexOf('mce-object ')!=0 && elm.className.indexOf('mce-preview-object ')!=0) return;
		
		// jsplayer
		var jsplayer = elm.dataset.mcePClass;
		if (!jsplayer || (jsplayer && jsplayer.indexOf('mediaelement')==-1)) win.find("#jsplayer")[0].checked(false);
		
		// usecontrols
		var usecontrols = elm.dataset.mcePControls;
		if (!usecontrols || usecontrols!='controls') win.find("#usecontrols")[0].checked(false);	

		// autoplay
		var autoplay = elm.dataset.mcePAutoplay;
		if (autoplay && autoplay=='autoplay') win.find("#autoplay")[0].checked(true);
		
		// Youtube autoplay
		if ((originalSource.indexOf("//www.youtube.com/")>-1 || originalSource.indexOf("//player.vimeo.com/video/")>-1 || originalSource.indexOf("//www.dailymotion.com/embed/")>-1) && originalSource.indexOf("autoplay=1")>-1) win.find("#autoplay")[0].checked(true);

		// Is in figure?
		var figure = editor.dom.getParents(elm, '.exe-figure');
		if (figure.length==1) {
			
			// imageheader
			var header = jQuery(".header",figure);
			if (header.length==1) {
				win.find("#imageheader").value(header.text());
			}
			
			// imagetitle & imagetitlelink
			var title = jQuery(".title",figure);
			if (title.length==1) {
				win.find("#imagetitle").value(title.text());
				if (title.prop("tagName")=="A") win.find("#imagetitlelink").value(title.attr("href"));
			}

			// authorname & authornamelink
			var author = jQuery(".author",figure);
			if (author.length==1) {
				win.find("#authorname").value(author.text());
				if (author.prop("tagName")=="A") win.find("#authornamelink").value(author.attr("href"));
			}
			
			// captionlicense
			var license = jQuery(".license",figure);
			if (license.length==1) {
				
				var licenseText = license.text().replace("(","").replace(")","").replace(_("License")+": ","");
				var licenseField = win.find("#captionlicense")[0];
				
				// CC0
				if (licenseText=="CC0") {
					licenseField.value("CC0");
				}				
				// CC-BY, CC-BY-SA, CC-BY-ND, CC-BY-NC, CC-BY-NC-SA, CC-BY-NC-ND						
				else if (licenseText.indexOf("CC ")==0) {
					licenseField.value(licenseText.replace(/ /g,'-').toUpperCase());
				} 
				// GNU/GPL
				else if (licenseText=="GNU/GPL") {
					licenseField.value("gnu-gpl");
				}
				// GFDL
				else if (licenseText=="GFDL") {
					licenseField.value("gfdl");
				}
				// Public Domain
				else if (licenseText==_("Public Domain")) {
					licenseField.value("pd");
				}	
				// All Rights Reserved
				else if (licenseText==_("All Rights Reserved") || licenseText==_("License")+": "+_("All Rights Reserved")) {
					licenseField.value("copyright");
				}
				// Custom license
				else if (licenseText!="") {
					editor.windowManager.alert(_('Please check the "License" field'));
					var customLicense = jQuery(".custom-license",figure);
					var customLicenseHTML = "";
					if (customLicense.length==1) {
						licenseText = customLicense.html();
					} else {
						// Needed if you add a custom license text and you add a link to that text in TinyMCE (span.custom-license might be removed)
						licenseText = license.html().replace('<span class="sep">(</span>','').replace('<span class="sep">)</span>','');
					}
					win.find("#customcaptionlicense")[0].value(licenseText);
					licenseField.value("custom");
					toggleCustomLicense("custom");	
				}
				
			}			
			
		}
		
		var htmlSourceField = document.getElementById("mcemediasource");
		var html = htmlSourceField.value;
		var source = '';
		
		// Check some formats using OBJECT (not swf files)
		
		// Old flv
		if (originalSource == "../templates/flowPlayer.swf") {
			
			editor.windowManager.confirm(
				_('This fragment uses old code. Would you like to update it? (necessary to be able to edit the parameters)'),
				function(s){
					if (s) {								
						
						if (html.indexOf('<param name="flv_src" value="')!=-1) {
							source = html.split('<param name="flv_src" value="')[1].split('"')[0];
						} else if (html.indexOf('<param name="exe_flv" value="')!=-1) {
							source = html.split('<param name="exe_flv" value="')[1].split('"')[0];
						} else if (html.indexOf("'playlist': [ { 'url': '")!=-1) {
							source = html.split("'playlist': [ { 'url': '")[1].split("'")[0];
						}
						
						if (source!='') {
							
							sourceField.value(source);
							win.find("#jsplayer")[0].checked(true);
							win.find("#usecontrols")[0].checked(true);
							
							var mediaWidth = win.find("#width").value();
							var mediaHeight = win.find("#height").value();
							if (mediaWidth == "") mediaWidth = 320;
							if (mediaHeight == "") mediaHeight = 240;

							var newSource = '<video width="'+mediaWidth+'" height="'+mediaHeight+'" class="mediaelement" controls="controls">';
								newSource += '<a href="'+source+'">'+source.replace("resources/","")+'</a>';
								newSource += '<source src="'+source+'" />';
							newSource += '</video>';
							
							win.find("#type")[0].value('video');
							
							htmlSourceField.value = newSource;
							
							htmlToData(newSource);
							
						} else {
							
							editor.windowManager.alert('flv - '+_('Could not retrieve data (Core error)'),function(){
								editor.windowManager.close();
							});
							
						}
						
					} else {
						
						editor.windowManager.close();
						
					}
					
				}
			);			
			
		} // / Old flv
		
		// Old mp3
		else if (originalSource.indexOf("../templates/xspf_player.swf") == 0) {
			
			editor.windowManager.confirm(
				_('You are using and old code. Update it (required to edit)?'),
				function(s){
					if (s) {								
						
						originalSource = originalSource.split('=resources/');
						
						if (originalSource.length>1) {
							source = "resources/"+originalSource[1].split('&')[0];
						}
						
						if (source!='' && source.indexOf(".mp3")!=-1) {
							
							sourceField.value(source);
							win.find("#jsplayer")[0].checked(true);
							win.find("#usecontrols")[0].checked(true);
							
							win.find("#width")[0].value("");
							win.find("#height")[0].value("");

							var newSource = '<audio class="mediaelement" src="'+source+'" controls="controls">';
								newSource += '<a href="'+source+'">'+source.replace("resources/","")+'</a>';
							newSource += '</audio>';
							
							win.find("#type")[0].value('audio');
							
							htmlSourceField.value = newSource;
							
							htmlToData(newSource);
							
						} else {
							
							editor.windowManager.alert('mp3 - '+_('Could not retrieve data (Core error)'),function(){
								editor.windowManager.close();
							});
							
						}
						
					} else {
						
						editor.windowManager.close();
						
					}
					
				}
			);			
			
		} // Old mp3
		
		// Other OBJECTs (not swf)
		else if (html.toLowerCase().indexOf("<object")!=-1) {
			
			if (html.indexOf('type="video/quicktime"')!=-1) {
				
				// It is QuickTime, so we recommend other formats
				currentFileIsQuickTime = true;
				editor.windowManager.alert(_('You are using QuickTime.\nWe recommend you to use any of these formats:\n') + recommendedFormats);				
				
			} else {
			
				if (html.indexOf('<param name="src" value="')!=-1) {
					
					source = html.split('<param name="src" value="')[1].split('"')[0];
					var sourceExt = source.substring(source.length-3,source.length).toLowerCase();
					
					if (sourceExt!="swf") {
						
						editor.windowManager.confirm(
							_('You are using and old code. Update it (required to edit)?'),
							function(s){
								if (s) {								
									
									if (source!='') {
										
										sourceField.value(source);
										win.find("#jsplayer")[0].checked(true);
										win.find("#usecontrols")[0].checked(true);
										
										var mediaWidth = win.find("#width").value();
										var mediaHeight = win.find("#height").value();
										if (mediaWidth == "") mediaWidth = 320;
										if (mediaHeight == "") mediaHeight = 240;

										var newSource = '<video width="'+mediaWidth+'" height="'+mediaHeight+'" class="mediaelement" controls="controls">';
											newSource += '<a href="'+source+'">'+source.replace("resources/","")+'</a>';
											newSource += '<source src="'+source+'" />';
										newSource += '</video>';
										
										win.find("#type")[0].value('video');
										
										htmlSourceField.value = newSource;
										
										htmlToData(newSource);
										
									} else {
										
										editor.windowManager.alert('Object - '+_('Could not retrieve data (Core error)'),function(){
											editor.windowManager.close();
										});
										
									}
									
								} else {
									
									editor.windowManager.close();
									
								}
								
							}
						);
						
					}
					
				}
			
			}
			
		}
			
	}
	
	function getSource() {
		var elm = editor.selection.getNode();
		if (elm.getAttribute('data-mce-object')) {
			return editor.selection.getContent();
		}
	}

	// TinyMCE's function (only the isDataEmbed param is new)
	function dataToHtml(data,isDataEmbed) { // isDataEmbed is optional
		var html = '';

		if (!data.source1) {
			tinymce.extend(data, htmlToData(data.embed));
			if (!data.source1) {
				return '';
			}
		}

		if (!data.source2) {
			data.source2 = '';
		}

		if (!data.poster) {
			data.poster = '';
		}

		data.source1 = editor.convertURL(data.source1, "source");
		data.source2 = editor.convertURL(data.source2, "source");
		data.source1mime = guessMime(data.source1);
		data.source2mime = guessMime(data.source2);
		data.poster = editor.convertURL(data.poster, "poster");
		data.flashPlayerUrl = editor.convertURL(url + '/moxieplayer.swf', "movie");

		tinymce.each(urlPatterns, function(pattern) {
			var match, i, url;

			if ((match = pattern.regex.exec(data.source1))) {
				url = pattern.url;

				for (i = 0; match[i]; i++) {
					/*jshint loopfunc:true*/
					/*eslint no-loop-func:0 */
					url = url.replace('$' + i, function() {
						return match[i];
					});
				}
				data.source1 = url;
				data.type = pattern.type;
				data.allowFullscreen = pattern.allowFullscreen;
				data.width = data.width || pattern.w;
				data.height = data.height || pattern.h;
			}
		});
		
		// IFRAME autoplay
		var iframeURL = data.source1;
		if (iframeURL.indexOf("//www.youtube.com/")>-1 || iframeURL.indexOf("//player.vimeo.com/video/")>-1 || iframeURL.indexOf("//www.dailymotion.com/embed/")>-1) {
			if (data.autoplay==true) {
				if (iframeURL.indexOf("autoplay=1")==-1) {
					var conn = "?";
					if (iframeURL.indexOf(conn)>-1) conn = "&";
					iframeURL += conn + "autoplay=1";
				}
			} else {
				// Remove autoplay
				iframeURL = iframeURL.replace("&autoplay=1","");
				iframeURL = iframeURL.replace("?autoplay=1&","?");
				iframeURL = iframeURL.replace("?autoplay=1","");
			}
			data.source1 = iframeURL;
		}

		if (isDataEmbed!=false && data.embed) {
			html = updateHtml(data.embed, data, true);
		} else {
			var videoScript = getVideoScriptMatch(data.source1);
			if (videoScript) {
				data.type = 'script';
				data.width = videoScript.width;
				data.height = videoScript.height;
			}

			data.width = data.width || 300;
			data.height = data.height || 150;

			tinymce.each(data, function(value, key) {
				data[key] = editor.dom.encode(value);
			});

			if (data.type == "iframe") {
				var allowFullscreen = data.allowFullscreen ? ' allowFullscreen="1"' : '';
				html += '<iframe src="' + data.source1 + '" width="' + data.width + '" height="' + data.height + '"' + allowFullscreen + '></iframe>';
			} else if (data.source1mime == "application/x-shockwave-flash") {
				html += '<object data="' + data.source1 + '" width="' + data.width + '" height="' + data.height + '" type="application/x-shockwave-flash">';
				html += '<param name="src" value="'+data.source1+'" />';
				if (data.poster) {
					html += '<img src="' + data.poster + '" width="' + data.width + '" height="' + data.height + '" />';
				}
				html += '</object>';
			} else if (data.type == 'audio' || data.source1mime.indexOf('audio') != -1) {
				html += (
					'<audio controls="controls" src="' + data.source1 + '">' +
						'<a href="' + data.source1 + '">'+data.source1mime+'</a>' +
						(data.source2 ? '\n<source src="' + data.source2 + '"' + (data.source2mime ? ' type="' + data.source2mime + '"' : '') + ' />\n' : '') +
					'</audio>'
				);
			} else if (data.type == "script") {
				html += '<script src="' + data.source1 + '"></script>';
			} else {
				html = (
					'<video width="' + data.width + '" height="' + data.height + '"' + (data.poster ? ' poster="' + data.poster + '"' : '') + ' controls="controls">\n' +
						'<source src="' + data.source1 + '"' + (data.source1mime ? ' type="' + data.source1mime + '"' : '') + ' />\n' +
						(data.source2 ? '<source src="' + data.source2 + '"' + (data.source2mime ? ' type="' + data.source2mime + '"' : '') + ' />\n' : '') +
					'</video>'
				);
			}
		}

		return html;
	}

	function htmlToData(html) {
		var data = {};

		new tinymce.html.SaxParser({
			validate: false,
			allow_conditional_comments: true,
			special: 'script,noscript',
			start: function(name, attrs) {
				if (!data.source1 && name == "param") {
					data.source1 = attrs.map.movie;
				}

				if (name == "iframe" || name == "object" || name == "embed" || name == "video" || name == "audio") {
					if (!data.type) {
						data.type = name;
					}

					data = tinymce.extend(attrs.map, data);
				}

				if (name == "script") {
					var videoScript = getVideoScriptMatch(attrs.map.src);
					if (!videoScript) {
						return;
					}

					data = {
						type: "script",
						source1: attrs.map.src,
						width: videoScript.width,
						height: videoScript.height
					};
				}

				if (name == "source") {
					if (!data.source1) {
						data.source1 = attrs.map.src;
					} else if (!data.source2) {
						data.source2 = attrs.map.src;
					}
				}

				if (name == "img" && !data.poster) {
					data.poster = attrs.map.src;
				}
			}
		}).parse(html);

		data.source1 = data.source1 || data.src || data.data;
		data.source2 = data.source2 || '';
		data.poster = data.poster || '';

		return data;
	}

	function getData(element) {
		if (element.getAttribute('data-mce-object')) {
			return htmlToData(editor.serializer.serialize(element, {selection: true}));
		}

		return {};
	}

	function sanitize(html) {
		if (editor.settings.media_filter_html === false) {
			return html;
		}

		var writer = new tinymce.html.Writer(), blocked;

		new tinymce.html.SaxParser({
			validate: false,
			allow_conditional_comments: false,
			special: 'script,noscript',

			comment: function(text) {
				writer.comment(text);
			},

			cdata: function(text) {
				writer.cdata(text);
			},

			text: function(text, raw) {
				writer.text(text, raw);
			},

			start: function(name, attrs, empty) {
				blocked = true;

				if (name == 'script' || name == 'noscript') {
					return;
				}

				for (var i = 0; i < attrs.length; i++) {
					if (attrs[i].name.indexOf('on') === 0) {
						return;
					}

					if (attrs[i].name == 'style') {
						attrs[i].value = editor.dom.serializeStyle(editor.dom.parseStyle(attrs[i].value), name);
					}
				}

				writer.start(name, attrs, empty);
				blocked = false;
			},

			end: function(name) {
				if (blocked) {
					return;
				}

				writer.end(name);
			}
		}, new tinymce.html.Schema({})).parse(html);

		return writer.getContent();
	}

	function updateHtml(html, data, updateAll) {
		var writer = new tinymce.html.Writer();
		var sourceCount = 0, hasImage;

		function setAttributes(attrs, updatedAttrs) {
			var name, i, value, attr;

			for (name in updatedAttrs) {
				value = "" + updatedAttrs[name];

				if (attrs.map[name]) {
					i = attrs.length;
					while (i--) {
						attr = attrs[i];

						if (attr.name == name) {
							if (value) {
								attrs.map[name] = value;
								attr.value = value;
							} else {
								delete attrs.map[name];
								attrs.splice(i, 1);
							}
						}
					}
				} else if (value) {
					attrs.push({
						name: name,
						value: value
					});

					attrs.map[name] = value;
				}
			}
		}

		new tinymce.html.SaxParser({
			validate: false,
			allow_conditional_comments: true,
			special: 'script,noscript',

			comment: function(text) {
				writer.comment(text);
			},

			cdata: function(text) {
				writer.cdata(text);
			},

			text: function(text, raw) {
				writer.text(text, raw);
			},

			start: function(name, attrs, empty) {
				switch (name) {
					case "video":
					case "object":
					case "embed":
					case "img":
					case "iframe":
						setAttributes(attrs, {
							width: data.width,
							height: data.height
						});
						break;
				}

				if (updateAll) {
					switch (name) {
						case "video":
							setAttributes(attrs, {
								poster: data.poster,
								src: ""
							});

							if (data.source2) {
								setAttributes(attrs, {
									src: ""
								});
							}
							break;

						case "iframe":
							setAttributes(attrs, {
								src: data.source1
							});
							break;

						case "source":
							sourceCount++;

							if (sourceCount <= 2) {
								setAttributes(attrs, {
									src: data["source" + sourceCount],
									type: data["source" + sourceCount + "mime"]
								});

								if (!data["source" + sourceCount]) {
									return;
								}
							}
							break;

						case "img":
							if (!data.poster) {
								return;
							}

							hasImage = true;
							break;
					}
				}

				writer.start(name, attrs, empty);
			},

			end: function(name) {
				if (name == "video" && updateAll) {
					for (var index = 1; index <= 2; index++) {
						if (data["source" + index]) {
							var attrs = [];
							attrs.map = {};

							if (sourceCount < index) {
								setAttributes(attrs, {
									src: data["source" + index],
									type: data["source" + index + "mime"]
								});

								writer.start("source", attrs, true);
							}
						}
					}
				}

				if (data.poster && name == "object" && updateAll && !hasImage) {
					var imgAttrs = [];
					imgAttrs.map = {};

					setAttributes(imgAttrs, {
						src: data.poster,
						width: data.width,
						height: data.height
					});

					writer.start("img", imgAttrs, true);
				}

				writer.end(name);
			}
		}, new tinymce.html.Schema({})).parse(html);

		return writer.getContent();
	}

	editor.on('ResolveName', function(e) {
		var name;

		if (e.target.nodeType == 1 && (name = e.target.getAttribute("data-mce-object"))) {
			e.name = name;
		}
	});

	function retainAttributesAndInnerHtml(sourceNode, targetNode) {
		var attrName, attrValue, attribs, ai, innerHtml;

		// Prefix all attributes except width, height and style since we
		// will add these to the placeholder
		attribs = sourceNode.attributes;
		ai = attribs.length;
		while (ai--) {
			attrName = attribs[ai].name;
			attrValue = attribs[ai].value;

			if (attrName !== "width" && attrName !== "height" && attrName !== "style") {
				if (attrName == "data" || attrName == "src") {
					attrValue = editor.convertURL(attrValue, attrName);
				}

				targetNode.attr('data-mce-p-' + attrName, attrValue);
			}
		}

		// Place the inner HTML contents inside an escaped attribute
		// This enables us to copy/paste the fake object
		innerHtml = sourceNode.firstChild && sourceNode.firstChild.value;
		if (innerHtml) {
			targetNode.attr("data-mce-html", escape(innerHtml));
			targetNode.firstChild = null;
		}
	}

	function createPlaceholderNode(node) {
		var placeHolder, name = node.name;

		placeHolder = new tinymce.html.Node('img', 1);
		placeHolder.shortEnded = true;

		retainAttributesAndInnerHtml(node, placeHolder);

		placeHolder.attr({
			width: node.attr('width') || "300",
			height: node.attr('height') || (name == "audio" ? "30" : "150"),
			style: node.attr('style'),
			src: tinymce.Env.transparentSrc,
			"data-mce-object": name,
			"class": "mce-object mce-object-" + name
		});

		return placeHolder;
	}

	function createPreviewNode(node) {
		var previewWrapper, previewNode, shimNode, name = node.name;

		previewWrapper = new tinymce.html.Node('span', 1);
		previewWrapper.attr({
			contentEditable: 'false',
			style: node.attr('style'),
			"data-mce-object": name,
			"class": "mce-preview-object mce-object-" + name
		});

		retainAttributesAndInnerHtml(node, previewWrapper);

		previewNode = new tinymce.html.Node(name, 1);
		previewNode.attr({
			src: node.attr('src'),
			allowfullscreen: node.attr('allowfullscreen'),
			width: node.attr('width') || "300",
			height: node.attr('height') || (name == "audio" ? "30" : "150"),
			frameborder: '0'
		});

		shimNode = new tinymce.html.Node('span', 1);
		shimNode.attr('class', 'mce-shim');

		previewWrapper.append(previewNode);
		previewWrapper.append(shimNode);

		return previewWrapper;
	}

	editor.on('preInit', function() {
		// Make sure that any messy HTML is retained inside these
		var specialElements = editor.schema.getSpecialElements();
		tinymce.each('video audio iframe object'.split(' '), function(name) {
			specialElements[name] = new RegExp('<\/' + name + '[^>]*>', 'gi');
		});

		// Allow elements
		// editor.schema.addValidElements('object[id|style|width|height|classid|codebase|*],embed[id|style|width|height|type|src|*],video[*],audio[*]');

		// Set allowFullscreen attribs as boolean
		var boolAttrs = editor.schema.getBoolAttrs();
		tinymce.each('webkitallowfullscreen mozallowfullscreen allowfullscreen'.split(' '), function(name) {
			boolAttrs[name] = {};
		});

		// Converts iframe, video etc into placeholder images
		editor.parser.addNodeFilter('iframe,video,audio,object,embed,script', function(nodes) {
			var i = nodes.length, node, placeHolder, videoScript;

			while (i--) {
				node = nodes[i];
				if (!node.parent) {
					continue;
				}

				if (node.parent.attr('data-mce-object')) {
					continue;
				}

				if (node.name == 'script') {
					videoScript = getVideoScriptMatch(node.attr('src'));
					if (!videoScript) {
						continue;
					}
				}

				if (videoScript) {
					if (videoScript.width) {
						node.attr('width', videoScript.width.toString());
					}

					if (videoScript.height) {
						node.attr('height', videoScript.height.toString());
					}
				}

				if (node.name == 'iframe' && editor.settings.media_live_embeds !== false && tinymce.Env.ceFalse) {
					placeHolder = createPreviewNode(node);
				} else {
					placeHolder = createPlaceholderNode(node);
				}

				node.replace(placeHolder);
			}
		});

		// Replaces placeholder images with real elements for video, object, iframe etc
		editor.serializer.addAttributeFilter('data-mce-object', function(nodes, name) {
			var i = nodes.length, node, realElm, ai, attribs, innerHtml, innerNode, realElmName, className;

			while (i--) {
				node = nodes[i];
				if (!node.parent) {
					continue;
				}

				realElmName = node.attr(name);
				realElm = new tinymce.html.Node(realElmName, 1);

				// Add width/height to everything but audio
				if (realElmName != "audio" && realElmName != "script") {
					className = node.attr('class');
					if (className && className.indexOf('mce-preview-object') !== -1) {
						realElm.attr({
							width: node.firstChild.attr('width'),
							height: node.firstChild.attr('height')
						});
					} else {
						realElm.attr({
							width: node.attr('width'),
							height: node.attr('height')
						});
					}
				}

				realElm.attr({
					style: node.attr('style')
				});

				// Unprefix all placeholder attributes
				attribs = node.attributes;
				ai = attribs.length;
				while (ai--) {
					var attrName = attribs[ai].name;

					if (attrName.indexOf('data-mce-p-') === 0) {
						realElm.attr(attrName.substr(11), attribs[ai].value);
					}
				}

				if (realElmName == "script") {
					realElm.attr('type', 'text/javascript');
				}

				// Inject innerhtml
				innerHtml = node.attr('data-mce-html');
				if (innerHtml) {
					innerNode = new tinymce.html.Node('#text', 3);
					innerNode.raw = true;
					innerNode.value = sanitize(unescape(innerHtml));
					realElm.append(innerNode);
				}

				node.replace(realElm);
			}
		});
	});

	editor.on('click keyup', function() {
		var selectedNode = editor.selection.getNode();

		if (selectedNode && editor.dom.hasClass(selectedNode, 'mce-preview-object')) {
			if (editor.dom.getAttrib(selectedNode, 'data-mce-selected')) {
				selectedNode.setAttribute('data-mce-selected', '2');
			}
		}
	});

	editor.on('ObjectSelected', function(e) {
		var objectType = e.target.getAttribute('data-mce-object');

		if (objectType == "audio" || objectType == "script") {
			e.preventDefault();
		}
	});

	editor.on('objectResized', function(e) {
		var target = e.target, html;

		if (target.getAttribute('data-mce-object')) {
			html = target.getAttribute('data-mce-html');
			if (html) {
				html = unescape(html);
				target.setAttribute('data-mce-html', escape(
					updateHtml(html, {
						width: e.width,
						height: e.height
					})
				));
			}
		}
	});

	editor.addButton('exemedia', {
		icon: 'media',
		tooltip: _("Insert/Edit Embedded Media"),
		onclick: showDialog,
		stateSelector: ['img[data-mce-object]', 'span[data-mce-object]']
	});

	editor.addMenuItem('exemedia', {
		icon: 'media',
		text: _("Insert/Edit Embedded Media"),
		onclick: showDialog,
		context: 'insert',
		prependToContext: true
	});
	
	// CSS required for the figures ("Title and Attribution")
	editor.on('init', function(e) {
		editor.dom.loadCSS(url + "/css/content.css");
	});	

	editor.on('setContent', function() {
		// TODO: This shouldn't be needed there should be a way to mark bogus
		// elements so they are never removed except external save
		editor.$('span.mce-preview-object').each(function(index, elm) {
			var $elm = editor.$(elm);

			if ($elm.find('span.mce-shim', elm).length === 0) {
				$elm.append('<span class="mce-shim"></span>');
			}
		});
	});
	
	editor.on('saveContent', function(e) {
		e.content = parse_media_html_attributes(editor.getContent());
	});	

	editor.addCommand('mceMedia', showDialog);

	this.showDialog = showDialog;
	
});
