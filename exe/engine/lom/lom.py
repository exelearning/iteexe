#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri May 10 13:36:48 2013 by generateDS.py version 2.9a.
#

import sys
import getopt
import re as re_
import base64
from datetime import datetime, tzinfo, timedelta
from twisted.spread.jelly import Unjellyable

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:
    from twisted.spread.jelly import Jellyable, Unjellyable

    class GeneratedsSuper(object, Jellyable, Unjellyable):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(tzinfo):
            def __init__(self, offset, name):
                self.__offset = timedelta(minutes = offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S')
            else:
                _svalue = input_data.strftime('%Y-%m-%dT%H:%M:%S.%f')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_datetime(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime.strptime(
                        input_data, '%Y-%m-%dT%H:%M:%S')
            return dt.replace(tzinfo = tz)

        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = input_data.strftime('%Y-%m-%d')
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_parse_date(self, input_data, node, input_name=''):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            return datetime.strptime(input_data,
                '%Y-%m-%d').replace(tzinfo = tz)
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'UTF-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' %
                (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' %
                (self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n'
                % (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class LanguageId(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if LanguageId.subclass:
            return LanguageId.subclass(*args_, **kwargs_)
        else:
            return LanguageId(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LanguageId', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LanguageId')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LanguageId'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LanguageId', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LanguageId'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LanguageId


class VCard(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VCard.subclass:
            return VCard.subclass(*args_, **kwargs_)
        else:
            return VCard(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VCard', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VCard')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VCard'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VCard', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VCard'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VCard


class LanguageString(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, string=None, extensiontype_=None):
        if string is None:
            self.string = []
        else:
            self.string = string
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if LanguageString.subclass:
            return LanguageString.subclass(*args_, **kwargs_)
        else:
            return LanguageString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_string(self): return self.string
    def set_string(self, string): self.string = string
    def add_string(self, value): self.string.append(value)
    def insert_string(self, index, value): self.string[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.string
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LanguageString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LanguageString')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LanguageString'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LanguageString', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for string_ in self.string:
            string_.export(outfile, level, namespace_, name_='string', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LanguageString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('string=[\n')
        level += 1
        for string_ in self.string:
            showIndent(outfile, level)
            outfile.write('model_.LangString(\n')
            string_.exportLiteral(outfile, level, name_='LangString')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'string':
            obj_ = LangString.factory()
            obj_.build(child_)
            self.string.append(obj_)
# end class LanguageString


class LangString(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, language=None, valueOf_=None):
        self.language = _cast(None, language)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LangString.subclass:
            return LangString.subclass(*args_, **kwargs_)
        else:
            return LangString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LangString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LangString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LangString'):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            outfile.write(' language=%s' % (self.gds_format_string(quote_attrib(self.language).encode(ExternalEncoding), input_name='language'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LangString', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LangString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.language is not None and 'language' not in already_processed:
            already_processed.add('language')
            showIndent(outfile, level)
            outfile.write('language = "%s",\n' % (self.language,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('language', node)
        if value is not None and 'language' not in already_processed:
            already_processed.add('language')
            self.language = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LangString


class DateTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, description=None, extensiontype_=None):
        self.dateTime = dateTime
        self.description = description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if DateTime.subclass:
            return DateTime.subclass(*args_, **kwargs_)
        else:
            return DateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTime'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DateTime'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.DateTimeValue(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = DateTimeValue.factory()
            obj_.build(child_)
            self.set_dateTime(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
# end class DateTime


class DateTimeValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DateTimeValue.subclass:
            return DateTimeValue.subclass(*args_, **kwargs_)
        else:
            return DateTimeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeValue'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeValue', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DateTimeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DateTimeValue


class Duration(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, duration=None, description=None, extensiontype_=None):
        self.duration = duration
        self.description = description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Duration.subclass:
            return Duration.subclass(*args_, **kwargs_)
        else:
            return Duration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.duration is not None or
            self.description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Duration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Duration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Duration'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Duration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.duration is not None:
            self.duration.export(outfile, level, namespace_, name_='duration', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Duration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=model_.DurationValue(\n')
            self.duration.exportLiteral(outfile, level, name_='duration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'duration':
            obj_ = DurationValue.factory()
            obj_.build(child_)
            self.set_duration(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
# end class Duration


class DurationValue(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DurationValue.subclass:
            return DurationValue.subclass(*args_, **kwargs_)
        else:
            return DurationValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DurationValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DurationValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DurationValue'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DurationValue', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DurationValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DurationValue


class lom(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, general=None, lifeCycle=None, metaMetadata=None, technical=None, educational=None, rights=None, relation=None, annotation=None, classification=None):
        self.general = general
        self.lifeCycle = lifeCycle
        self.metaMetadata = metaMetadata
        self.technical = technical
        if educational is None:
            self.educational = []
        else:
            self.educational = educational
        self.rights = rights
        if relation is None:
            self.relation = []
        else:
            self.relation = relation
        if annotation is None:
            self.annotation = []
        else:
            self.annotation = annotation
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
    def factory(*args_, **kwargs_):
        if lom.subclass:
            return lom.subclass(*args_, **kwargs_)
        else:
            return lom(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_general(self): return self.general
    def set_general(self, general): self.general = general
    def get_lifeCycle(self): return self.lifeCycle
    def set_lifeCycle(self, lifeCycle): self.lifeCycle = lifeCycle
    def get_metaMetadata(self): return self.metaMetadata
    def set_metaMetadata(self, metaMetadata): self.metaMetadata = metaMetadata
    def get_technical(self): return self.technical
    def set_technical(self, technical): self.technical = technical
    def get_educational(self): return self.educational
    def set_educational(self, educational): self.educational = educational
    def add_educational(self, value): self.educational.append(value)
    def insert_educational(self, index, value): self.educational[index] = value
    def get_rights(self): return self.rights
    def set_rights(self, rights): self.rights = rights
    def get_relation(self): return self.relation
    def set_relation(self, relation): self.relation = relation
    def add_relation(self, value): self.relation.append(value)
    def insert_relation(self, index, value): self.relation[index] = value
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def add_annotation(self, value): self.annotation.append(value)
    def insert_annotation(self, index, value): self.annotation[index] = value
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def add_classification(self, value): self.classification.append(value)
    def insert_classification(self, index, value): self.classification[index] = value
    def hasContent_(self):
        if (
            self.general is not None or
            self.lifeCycle is not None or
            self.metaMetadata is not None or
            self.technical is not None or
            self.educational or
            self.rights is not None or
            self.relation or
            self.annotation or
            self.classification
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lom', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lom')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lom'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='lom', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.general is not None:
            self.general.export(outfile, level, namespace_, name_='general', pretty_print=pretty_print)
        if self.lifeCycle is not None:
            self.lifeCycle.export(outfile, level, namespace_, name_='lifeCycle', pretty_print=pretty_print)
        if self.metaMetadata is not None:
            self.metaMetadata.export(outfile, level, namespace_, name_='metaMetadata', pretty_print=pretty_print)
        if self.technical is not None:
            self.technical.export(outfile, level, namespace_, name_='technical', pretty_print=pretty_print)
        for educational_ in self.educational:
            educational_.export(outfile, level, namespace_, name_='educational', pretty_print=pretty_print)
        if self.rights is not None:
            self.rights.export(outfile, level, namespace_, name_='rights', pretty_print=pretty_print)
        for relation_ in self.relation:
            relation_.export(outfile, level, namespace_, name_='relation', pretty_print=pretty_print)
        for annotation_ in self.annotation:
            annotation_.export(outfile, level, namespace_, name_='annotation', pretty_print=pretty_print)
        for classification_ in self.classification:
            classification_.export(outfile, level, namespace_, name_='classification', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='lom'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.general is not None:
            showIndent(outfile, level)
            outfile.write('general=model_.general(\n')
            self.general.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lifeCycle is not None:
            showIndent(outfile, level)
            outfile.write('lifeCycle=model_.lifeCycle(\n')
            self.lifeCycle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metaMetadata is not None:
            showIndent(outfile, level)
            outfile.write('metaMetadata=model_.metaMetadata(\n')
            self.metaMetadata.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.technical is not None:
            showIndent(outfile, level)
            outfile.write('technical=model_.technical(\n')
            self.technical.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('educational=[\n')
        level += 1
        for educational_ in self.educational:
            showIndent(outfile, level)
            outfile.write('model_.educational(\n')
            educational_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.rights is not None:
            showIndent(outfile, level)
            outfile.write('rights=model_.rights(\n')
            self.rights.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('relation=[\n')
        level += 1
        for relation_ in self.relation:
            showIndent(outfile, level)
            outfile.write('model_.relation(\n')
            relation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('annotation=[\n')
        level += 1
        for annotation_ in self.annotation:
            showIndent(outfile, level)
            outfile.write('model_.annotation(\n')
            annotation_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('classification=[\n')
        level += 1
        for classification_ in self.classification:
            showIndent(outfile, level)
            outfile.write('model_.classification(\n')
            classification_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'general':
            obj_ = general.factory()
            obj_.build(child_)
            self.set_general(obj_)
        elif nodeName_ == 'lifeCycle':
            obj_ = lifeCycle.factory()
            obj_.build(child_)
            self.set_lifeCycle(obj_)
        elif nodeName_ == 'metaMetadata':
            obj_ = metaMetadata.factory()
            obj_.build(child_)
            self.set_metaMetadata(obj_)
        elif nodeName_ == 'technical':
            obj_ = technical.factory()
            obj_.build(child_)
            self.set_technical(obj_)
        elif nodeName_ == 'educational':
            obj_ = educational.factory()
            obj_.build(child_)
            self.educational.append(obj_)
        elif nodeName_ == 'rights':
            obj_ = rights.factory()
            obj_.build(child_)
            self.set_rights(obj_)
        elif nodeName_ == 'relation':
            obj_ = relation.factory()
            obj_.build(child_)
            self.relation.append(obj_)
        elif nodeName_ == 'annotation':
            obj_ = annotation.factory()
            obj_.build(child_)
            self.annotation.append(obj_)
        elif nodeName_ == 'classification':
            obj_ = classification.factory()
            obj_.build(child_)
            self.classification.append(obj_)
# end class lom


class general(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, identifier=None, title=None, language=None, description=None, keyword=None, coverage=None, structure=None, aggregationLevel=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        self.title = title
        if language is None:
            self.language = []
        else:
            self.language = language
        if description is None:
            self.description = []
        else:
            self.description = description
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
        if coverage is None:
            self.coverage = []
        else:
            self.coverage = coverage
        self.structure = structure
        self.aggregationLevel = aggregationLevel
    def factory(*args_, **kwargs_):
        if general.subclass:
            return general.subclass(*args_, **kwargs_)
        else:
            return general(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def add_identifier(self, value): self.identifier.append(value)
    def insert_identifier(self, index, value): self.identifier[index] = value
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language(self, index, value): self.language[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_keyword(self): return self.keyword
    def set_keyword(self, keyword): self.keyword = keyword
    def add_keyword(self, value): self.keyword.append(value)
    def insert_keyword(self, index, value): self.keyword[index] = value
    def get_coverage(self): return self.coverage
    def set_coverage(self, coverage): self.coverage = coverage
    def add_coverage(self, value): self.coverage.append(value)
    def insert_coverage(self, index, value): self.coverage[index] = value
    def get_structure(self): return self.structure
    def set_structure(self, structure): self.structure = structure
    def get_aggregationLevel(self): return self.aggregationLevel
    def set_aggregationLevel(self, aggregationLevel): self.aggregationLevel = aggregationLevel
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.identifier or
            self.title is not None or
            self.language or
            self.description or
            self.keyword or
            self.coverage or
            self.structure is not None or
            self.aggregationLevel is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='general', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='general')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='general'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='general', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for identifier_ in self.identifier:
            identifier_.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', pretty_print=pretty_print)
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for keyword_ in self.keyword:
            keyword_.export(outfile, level, namespace_, name_='keyword', pretty_print=pretty_print)
        for coverage_ in self.coverage:
            coverage_.export(outfile, level, namespace_, name_='coverage', pretty_print=pretty_print)
        if self.structure is not None:
            self.structure.export(outfile, level, namespace_, name_='structure', pretty_print=pretty_print)
        if self.aggregationLevel is not None:
            self.aggregationLevel.export(outfile, level, namespace_, name_='aggregationLevel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='general'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('identifier=[\n')
        level += 1
        for identifier_ in self.identifier:
            showIndent(outfile, level)
            outfile.write('model_.identifier(\n')
            identifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.title(\n')
            self.title.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('model_.LanguageId(\n')
            language_.exportLiteral(outfile, level, name_='LanguageId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.LanguageString(\n')
            description_.exportLiteral(outfile, level, name_='LanguageString')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('keyword=[\n')
        level += 1
        for keyword_ in self.keyword:
            showIndent(outfile, level)
            outfile.write('model_.keyword(\n')
            keyword_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('coverage=[\n')
        level += 1
        for coverage_ in self.coverage:
            showIndent(outfile, level)
            outfile.write('model_.coverage(\n')
            coverage_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.structure is not None:
            showIndent(outfile, level)
            outfile.write('structure=model_.structure(\n')
            self.structure.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.aggregationLevel is not None:
            showIndent(outfile, level)
            outfile.write('aggregationLevel=model_.aggregationLevel(\n')
            self.aggregationLevel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
        elif nodeName_ == 'title':
            obj_ = title.factory()
            obj_.build(child_)
            self.set_title(obj_)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, LanguageId)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.language.append(obj_)
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, LanguageString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'keyword':
            obj_ = keyword.factory()
            obj_.build(child_)
            self.keyword.append(obj_)
        elif nodeName_ == 'coverage':
            obj_ = coverage.factory()
            obj_.build(child_)
            self.coverage.append(obj_)
        elif nodeName_ == 'structure':
            class_obj_ = self.get_class_obj_(child_, structure)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_structure(obj_)
        elif nodeName_ == 'aggregationLevel':
            class_obj_ = self.get_class_obj_(child_, aggregationLevel)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_aggregationLevel(obj_)
# end class general


class identifier(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, catalog=None, entry=None):
        self.catalog = catalog
        self.entry = entry
    def factory(*args_, **kwargs_):
        if identifier.subclass:
            return identifier.subclass(*args_, **kwargs_)
        else:
            return identifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def hasContent_(self):
        if (
            self.catalog is not None or
            self.entry is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='identifier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='identifier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='identifier'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='identifier', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.catalog is not None:
            self.catalog.export(outfile, level, namespace_, name_='catalog', pretty_print=pretty_print)
        if self.entry is not None:
            self.entry.export(outfile, level, namespace_, name_='entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='identifier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.catalog is not None:
            showIndent(outfile, level)
            outfile.write('catalog=model_.catalog(\n')
            self.catalog.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.entry is not None:
            showIndent(outfile, level)
            outfile.write('entry=model_.entry(\n')
            self.entry.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'catalog':
            obj_ = catalog.factory()
            obj_.build(child_)
            self.set_catalog(obj_)
        elif nodeName_ == 'entry':
            obj_ = entry.factory()
            obj_.build(child_)
            self.set_entry(obj_)
# end class identifier


class catalog(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if catalog.subclass:
            return catalog.subclass(*args_, **kwargs_)
        else:
            return catalog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='catalog', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='catalog')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='catalog'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='catalog', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='catalog'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class catalog


class entry(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if entry.subclass:
            return entry.subclass(*args_, **kwargs_)
        else:
            return entry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entry', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entry')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entry'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entry', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='entry'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class entry


class title(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None, uniqueElementName=None):
        super(title, self).__init__(string, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        pass
    def factory(*args_, **kwargs_):
        if title.subclass:
            return title.subclass(*args_, **kwargs_)
        else:
            return title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(title, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='title', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='title'):
        super(title, self).exportAttributes(outfile, level, already_processed, namespace_, name_='title')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='title', fromsubclass_=False, pretty_print=True):
        super(title, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='title'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(title, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(title, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(title, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(title, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class title


class language(LanguageId):
    subclass = None
    superclass = LanguageId
    def __init__(self, valueOf_=None):
        super(language, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if language.subclass:
            return language.subclass(*args_, **kwargs_)
        else:
            return language(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(language, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='language', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='language')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='language'):
        super(language, self).exportAttributes(outfile, level, already_processed, namespace_, name_='language')
    def exportChildren(self, outfile, level, namespace_='', name_='language', fromsubclass_=False, pretty_print=True):
        super(language, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='language'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(language, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(language, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(language, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class language


class keyword(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None):
        super(keyword, self).__init__(string, )
        pass
    def factory(*args_, **kwargs_):
        if keyword.subclass:
            return keyword.subclass(*args_, **kwargs_)
        else:
            return keyword(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(keyword, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='keyword', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='keyword')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='keyword'):
        super(keyword, self).exportAttributes(outfile, level, already_processed, namespace_, name_='keyword')
    def exportChildren(self, outfile, level, namespace_='', name_='keyword', fromsubclass_=False, pretty_print=True):
        super(keyword, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='keyword'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(keyword, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(keyword, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(keyword, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(keyword, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class keyword


class coverage(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None):
        super(coverage, self).__init__(string, )
        pass
    def factory(*args_, **kwargs_):
        if coverage.subclass:
            return coverage.subclass(*args_, **kwargs_)
        else:
            return coverage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(coverage, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='coverage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='coverage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='coverage'):
        super(coverage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='coverage')
    def exportChildren(self, outfile, level, namespace_='', name_='coverage', fromsubclass_=False, pretty_print=True):
        super(coverage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='coverage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(coverage, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(coverage, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(coverage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(coverage, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class coverage


class lifeCycle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, version=None, status=None, contribute=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.version = version
        self.status = status
        if contribute is None:
            self.contribute = []
        else:
            self.contribute = contribute
    def factory(*args_, **kwargs_):
        if lifeCycle.subclass:
            return lifeCycle.subclass(*args_, **kwargs_)
        else:
            return lifeCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_contribute(self): return self.contribute
    def set_contribute(self, contribute): self.contribute = contribute
    def add_contribute(self, value): self.contribute.append(value)
    def insert_contribute(self, index, value): self.contribute[index] = value
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.version is not None or
            self.status is not None or
            self.contribute
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='lifeCycle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='lifeCycle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='lifeCycle'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='lifeCycle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
        if self.status is not None:
            self.status.export(outfile, level, namespace_, name_='status', pretty_print=pretty_print)
        for contribute_ in self.contribute:
            contribute_.export(outfile, level, namespace_, name_='contribute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='lifeCycle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.version(\n')
            self.version.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=model_.status(\n')
            self.status.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('contribute=[\n')
        level += 1
        for contribute_ in self.contribute:
            showIndent(outfile, level)
            outfile.write('model_.contribute(\n')
            contribute_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'version':
            obj_ = version.factory()
            obj_.build(child_)
            self.set_version(obj_)
        elif nodeName_ == 'status':
            class_obj_ = self.get_class_obj_(child_, status)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_status(obj_)
        elif nodeName_ == 'contribute':
            obj_ = contribute.factory()
            obj_.build(child_)
            self.contribute.append(obj_)
# end class lifeCycle


class version(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None, uniqueElementName=None):
        super(version, self).__init__(string, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        pass
    def factory(*args_, **kwargs_):
        if version.subclass:
            return version.subclass(*args_, **kwargs_)
        else:
            return version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(version, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='version', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='version'):
        super(version, self).exportAttributes(outfile, level, already_processed, namespace_, name_='version')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='version', fromsubclass_=False, pretty_print=True):
        super(version, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='version'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(version, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(version, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(version, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(version, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class version


class contribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, role=None, entity=None, date=None):
        self.role = role
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
        self.date = date
    def factory(*args_, **kwargs_):
        if contribute.subclass:
            return contribute.subclass(*args_, **kwargs_)
        else:
            return contribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity(self, index, value): self.entity[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def hasContent_(self):
        if (
            self.role is not None or
            self.entity or
            self.date is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contribute', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contribute'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        for entity_ in self.entity:
            entity_.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
        if self.date is not None:
            self.date.export(outfile, level, namespace_, name_='date', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='contribute'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.role is not None:
            showIndent(outfile, level)
            outfile.write('role=model_.role(\n')
            self.role.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('entity=[\n')
        level += 1
        for entity_ in self.entity:
            showIndent(outfile, level)
            outfile.write('model_.VCard(\n')
            entity_.exportLiteral(outfile, level, name_='VCard')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('date=model_.date(\n')
            self.date.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'role':
            class_obj_ = self.get_class_obj_(child_, role)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_role(obj_)
        elif nodeName_ == 'entity':
            class_obj_ = self.get_class_obj_(child_, VCard)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.entity.append(obj_)
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.set_date(obj_)
# end class contribute


class date(DateTime):
    subclass = None
    superclass = DateTime
    def __init__(self, dateTime=None, description=None, uniqueElementName=None, valueOf_=None):
        super(date, self).__init__(dateTime, description, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if date.subclass:
            return date.subclass(*args_, **kwargs_)
        else:
            return date(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(date, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='date', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='date')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='date'):
        super(date, self).exportAttributes(outfile, level, already_processed, namespace_, name_='date')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='date', fromsubclass_=False, pretty_print=True):
        super(date, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='date'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(date, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(date, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(date, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(date, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class date


class metaMetadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, identifier=None, contribute=None, metadataSchema=None, language=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        if identifier is None:
            self.identifier = []
        else:
            self.identifier = identifier
        if contribute is None:
            self.contribute = []
        else:
            self.contribute = contribute
        if metadataSchema is None:
            self.metadataSchema = []
        else:
            self.metadataSchema = metadataSchema
        self.language = language
    def factory(*args_, **kwargs_):
        if metaMetadata.subclass:
            return metaMetadata.subclass(*args_, **kwargs_)
        else:
            return metaMetadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def add_identifier(self, value): self.identifier.append(value)
    def insert_identifier(self, index, value): self.identifier[index] = value
    def get_contribute(self): return self.contribute
    def set_contribute(self, contribute): self.contribute = contribute
    def add_contribute(self, value): self.contribute.append(value)
    def insert_contribute(self, index, value): self.contribute[index] = value
    def get_metadataSchema(self): return self.metadataSchema
    def set_metadataSchema(self, metadataSchema): self.metadataSchema = metadataSchema
    def add_metadataSchema(self, value): self.metadataSchema.append(value)
    def insert_metadataSchema(self, index, value): self.metadataSchema[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.identifier or
            self.contribute or
            self.metadataSchema or
            self.language is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='metaMetadata', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metaMetadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='metaMetadata'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='metaMetadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for identifier_ in self.identifier:
            identifier_.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
        for contribute_ in self.contribute:
            contribute_.export(outfile, level, namespace_, name_='contribute', pretty_print=pretty_print)
        for metadataSchema_ in self.metadataSchema:
            metadataSchema_.export(outfile, level, namespace_, name_='metadataSchema', pretty_print=pretty_print)
        if self.language is not None:
            self.language.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='metaMetadata'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('identifier=[\n')
        level += 1
        for identifier_ in self.identifier:
            showIndent(outfile, level)
            outfile.write('model_.identifier(\n')
            identifier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contribute=[\n')
        level += 1
        for contribute_ in self.contribute:
            showIndent(outfile, level)
            outfile.write('model_.contributeMeta(\n')
            contribute_.exportLiteral(outfile, level, name_='contributeMeta')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('metadataSchema=[\n')
        level += 1
        for metadataSchema_ in self.metadataSchema:
            showIndent(outfile, level)
            outfile.write('model_.metadataSchema(\n')
            metadataSchema_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.language is not None:
            showIndent(outfile, level)
            outfile.write('language=model_.LanguageId(\n')
            self.language.exportLiteral(outfile, level, name_='language')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.identifier.append(obj_)
        elif nodeName_ == 'contribute':
            obj_ = contributeMeta.factory()
            obj_.build(child_)
            self.contribute.append(obj_)
        elif nodeName_ == 'metadataSchema':
            obj_ = metadataSchema.factory()
            obj_.build(child_)
            self.metadataSchema.append(obj_)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, LanguageId)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_language(obj_)
# end class metaMetadata


class contributeMeta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, role=None, entity=None, date=None):
        self.role = role
        if entity is None:
            self.entity = []
        else:
            self.entity = entity
        self.date = date
    def factory(*args_, **kwargs_):
        if contributeMeta.subclass:
            return contributeMeta.subclass(*args_, **kwargs_)
        else:
            return contributeMeta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_role(self): return self.role
    def set_role(self, role): self.role = role
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def add_entity(self, value): self.entity.append(value)
    def insert_entity(self, index, value): self.entity[index] = value
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def hasContent_(self):
        if (
            self.role is not None or
            self.entity or
            self.date is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contributeMeta', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contributeMeta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contributeMeta'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contributeMeta', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.role is not None:
            self.role.export(outfile, level, namespace_, name_='role', pretty_print=pretty_print)
        for entity_ in self.entity:
            entity_.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
        if self.date is not None:
            self.date.export(outfile, level, namespace_, name_='date', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='contributeMeta'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.role is not None:
            showIndent(outfile, level)
            outfile.write('role=model_.roleMeta(\n')
            self.role.exportLiteral(outfile, level, name_='role')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('entity=[\n')
        level += 1
        for entity_ in self.entity:
            showIndent(outfile, level)
            outfile.write('model_.VCard(\n')
            entity_.exportLiteral(outfile, level, name_='VCard')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('date=model_.date(\n')
            self.date.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'role':
            class_obj_ = self.get_class_obj_(child_, roleMeta)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_role(obj_)
        elif nodeName_ == 'entity':
            class_obj_ = self.get_class_obj_(child_, VCard)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.entity.append(obj_)
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.set_date(obj_)
# end class contributeMeta


class metadataSchema(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if metadataSchema.subclass:
            return metadataSchema.subclass(*args_, **kwargs_)
        else:
            return metadataSchema(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='metadataSchema', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metadataSchema')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='metadataSchema'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='metadataSchema', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='metadataSchema'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class metadataSchema


class technical(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, format=None, size=None, location=None, requirement=None, installationRemarks=None, otherPlatformRequirements=None, duration=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        if format is None:
            self.format = []
        else:
            self.format = format
        self.size = size
        if location is None:
            self.location = []
        else:
            self.location = location
        if requirement is None:
            self.requirement = []
        else:
            self.requirement = requirement
        self.installationRemarks = installationRemarks
        self.otherPlatformRequirements = otherPlatformRequirements
        self.duration = duration
    def factory(*args_, **kwargs_):
        if technical.subclass:
            return technical.subclass(*args_, **kwargs_)
        else:
            return technical(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def add_format(self, value): self.format.append(value)
    def insert_format(self, index, value): self.format[index] = value
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_location(self): return self.location
    def set_location(self, location): self.location = location
    def add_location(self, value): self.location.append(value)
    def insert_location(self, index, value): self.location[index] = value
    def get_requirement(self): return self.requirement
    def set_requirement(self, requirement): self.requirement = requirement
    def add_requirement(self, value): self.requirement.append(value)
    def insert_requirement(self, index, value): self.requirement[index] = value
    def get_installationRemarks(self): return self.installationRemarks
    def set_installationRemarks(self, installationRemarks): self.installationRemarks = installationRemarks
    def get_otherPlatformRequirements(self): return self.otherPlatformRequirements
    def set_otherPlatformRequirements(self, otherPlatformRequirements): self.otherPlatformRequirements = otherPlatformRequirements
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.format or
            self.size is not None or
            self.location or
            self.requirement or
            self.installationRemarks is not None or
            self.otherPlatformRequirements is not None or
            self.duration is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='technical', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='technical')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='technical'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='technical', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for format_ in self.format:
            format_.export(outfile, level, namespace_, name_='format', pretty_print=pretty_print)
        if self.size is not None:
            self.size.export(outfile, level, namespace_, name_='size', pretty_print=pretty_print)
        for location_ in self.location:
            location_.export(outfile, level, namespace_, name_='location', pretty_print=pretty_print)
        for requirement_ in self.requirement:
            requirement_.export(outfile, level, namespace_, name_='requirement', pretty_print=pretty_print)
        if self.installationRemarks is not None:
            self.installationRemarks.export(outfile, level, namespace_, name_='installationRemarks', pretty_print=pretty_print)
        if self.otherPlatformRequirements is not None:
            self.otherPlatformRequirements.export(outfile, level, namespace_, name_='otherPlatformRequirements', pretty_print=pretty_print)
        if self.duration is not None:
            self.duration.export(outfile, level, namespace_, name_='duration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='technical'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('format=[\n')
        level += 1
        for format_ in self.format:
            showIndent(outfile, level)
            outfile.write('model_.format(\n')
            format_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=model_.size(\n')
            self.size.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('location=[\n')
        level += 1
        for location_ in self.location:
            showIndent(outfile, level)
            outfile.write('model_.location(\n')
            location_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('requirement=[\n')
        level += 1
        for requirement_ in self.requirement:
            showIndent(outfile, level)
            outfile.write('model_.requirement(\n')
            requirement_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.installationRemarks is not None:
            showIndent(outfile, level)
            outfile.write('installationRemarks=model_.installationRemarks(\n')
            self.installationRemarks.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.otherPlatformRequirements is not None:
            showIndent(outfile, level)
            outfile.write('otherPlatformRequirements=model_.otherPlatformRequirements(\n')
            self.otherPlatformRequirements.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=model_.duration(\n')
            self.duration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'format':
            obj_ = format.factory()
            obj_.build(child_)
            self.format.append(obj_)
        elif nodeName_ == 'size':
            obj_ = size.factory()
            obj_.build(child_)
            self.set_size(obj_)
        elif nodeName_ == 'location':
            obj_ = location.factory()
            obj_.build(child_)
            self.location.append(obj_)
        elif nodeName_ == 'requirement':
            obj_ = requirement.factory()
            obj_.build(child_)
            self.requirement.append(obj_)
        elif nodeName_ == 'installationRemarks':
            obj_ = installationRemarks.factory()
            obj_.build(child_)
            self.set_installationRemarks(obj_)
        elif nodeName_ == 'otherPlatformRequirements':
            obj_ = otherPlatformRequirements.factory()
            obj_.build(child_)
            self.set_otherPlatformRequirements(obj_)
        elif nodeName_ == 'duration':
            obj_ = duration.factory()
            obj_.build(child_)
            self.set_duration(obj_)
# end class technical


class format(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if format.subclass:
            return format.subclass(*args_, **kwargs_)
        else:
            return format(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='format', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='format')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='format'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='format', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='format'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class format


class size(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if size.subclass:
            return size.subclass(*args_, **kwargs_)
        else:
            return size(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='size', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='size')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='size'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='size', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='size'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class size


class location(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if location.subclass:
            return location.subclass(*args_, **kwargs_)
        else:
            return location(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='location', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='location')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='location'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='location', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='location'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class location


class requirement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orComposite=None):
        if orComposite is None:
            self.orComposite = []
        else:
            self.orComposite = orComposite
    def factory(*args_, **kwargs_):
        if requirement.subclass:
            return requirement.subclass(*args_, **kwargs_)
        else:
            return requirement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orComposite(self): return self.orComposite
    def set_orComposite(self, orComposite): self.orComposite = orComposite
    def add_orComposite(self, value): self.orComposite.append(value)
    def insert_orComposite(self, index, value): self.orComposite[index] = value
    def hasContent_(self):
        if (
            self.orComposite
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='requirement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='requirement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='requirement'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='requirement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for orComposite_ in self.orComposite:
            orComposite_.export(outfile, level, namespace_, name_='orComposite', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='requirement'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('orComposite=[\n')
        level += 1
        for orComposite_ in self.orComposite:
            showIndent(outfile, level)
            outfile.write('model_.orComposite(\n')
            orComposite_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orComposite':
            obj_ = orComposite.factory()
            obj_.build(child_)
            self.orComposite.append(obj_)
# end class requirement


class orComposite(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, name=None, minimumVersion=None, maximumVersion=None):
        self.type_ = type_
        self.name = name
        self.minimumVersion = minimumVersion
        self.maximumVersion = maximumVersion
    def factory(*args_, **kwargs_):
        if orComposite.subclass:
            return orComposite.subclass(*args_, **kwargs_)
        else:
            return orComposite(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_minimumVersion(self): return self.minimumVersion
    def set_minimumVersion(self, minimumVersion): self.minimumVersion = minimumVersion
    def get_maximumVersion(self): return self.maximumVersion
    def set_maximumVersion(self, maximumVersion): self.maximumVersion = maximumVersion
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.name is not None or
            self.minimumVersion is not None or
            self.maximumVersion is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='orComposite', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='orComposite')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='orComposite'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='orComposite', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.name is not None:
            self.name.export(outfile, level, namespace_, name_='name', pretty_print=pretty_print)
        if self.minimumVersion is not None:
            self.minimumVersion.export(outfile, level, namespace_, name_='minimumVersion', pretty_print=pretty_print)
        if self.maximumVersion is not None:
            self.maximumVersion.export(outfile, level, namespace_, name_='maximumVersion', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='orComposite'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.type_(\n')
            self.type_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=model_.name(\n')
            self.name.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minimumVersion is not None:
            showIndent(outfile, level)
            outfile.write('minimumVersion=model_.minimumVersion(\n')
            self.minimumVersion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maximumVersion is not None:
            showIndent(outfile, level)
            outfile.write('maximumVersion=model_.maximumVersion(\n')
            self.maximumVersion.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = type_.factory()
            obj_.build(child_)
            self.set_type(obj_)
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, name)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_name(obj_)
        elif nodeName_ == 'minimumVersion':
            obj_ = minimumVersion.factory()
            obj_.build(child_)
            self.set_minimumVersion(obj_)
        elif nodeName_ == 'maximumVersion':
            obj_ = maximumVersion.factory()
            obj_.build(child_)
            self.set_maximumVersion(obj_)
# end class orComposite


class minimumVersion(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if minimumVersion.subclass:
            return minimumVersion.subclass(*args_, **kwargs_)
        else:
            return minimumVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='minimumVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='minimumVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='minimumVersion'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='minimumVersion', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='minimumVersion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class minimumVersion


class maximumVersion(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if maximumVersion.subclass:
            return maximumVersion.subclass(*args_, **kwargs_)
        else:
            return maximumVersion(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='maximumVersion', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='maximumVersion')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='maximumVersion'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='maximumVersion', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='maximumVersion'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class maximumVersion


class installationRemarks(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None, uniqueElementName=None):
        super(installationRemarks, self).__init__(string, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        pass
    def factory(*args_, **kwargs_):
        if installationRemarks.subclass:
            return installationRemarks.subclass(*args_, **kwargs_)
        else:
            return installationRemarks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(installationRemarks, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='installationRemarks', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='installationRemarks')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='installationRemarks'):
        super(installationRemarks, self).exportAttributes(outfile, level, already_processed, namespace_, name_='installationRemarks')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='installationRemarks', fromsubclass_=False, pretty_print=True):
        super(installationRemarks, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='installationRemarks'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(installationRemarks, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(installationRemarks, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(installationRemarks, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(installationRemarks, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class installationRemarks


class otherPlatformRequirements(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None):
        super(otherPlatformRequirements, self).__init__(string, )
        pass
    def factory(*args_, **kwargs_):
        if otherPlatformRequirements.subclass:
            return otherPlatformRequirements.subclass(*args_, **kwargs_)
        else:
            return otherPlatformRequirements(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(otherPlatformRequirements, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='otherPlatformRequirements', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='otherPlatformRequirements')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='otherPlatformRequirements'):
        super(otherPlatformRequirements, self).exportAttributes(outfile, level, already_processed, namespace_, name_='otherPlatformRequirements')
    def exportChildren(self, outfile, level, namespace_='', name_='otherPlatformRequirements', fromsubclass_=False, pretty_print=True):
        super(otherPlatformRequirements, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='otherPlatformRequirements'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(otherPlatformRequirements, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(otherPlatformRequirements, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(otherPlatformRequirements, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(otherPlatformRequirements, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class otherPlatformRequirements


class duration(Duration):
    subclass = None
    superclass = Duration
    def __init__(self, durationf=None, description=None, uniqueElementName=None, valueOf_=None):
        super(duration, self).__init__(durationf, description, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if duration.subclass:
            return duration.subclass(*args_, **kwargs_)
        else:
            return duration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(duration, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='duration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='duration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='duration'):
        super(duration, self).exportAttributes(outfile, level, already_processed, namespace_, name_='duration')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='duration', fromsubclass_=False, pretty_print=True):
        super(duration, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='duration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(duration, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(duration, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(duration, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(duration, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class duration


class educational(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, interactivityType=None, learningResourceType=None, interactivityLevel=None, semanticDensity=None, intendedEndUserRole=None, context=None, typicalAgeRange=None, difficulty=None, typicalLearningTime=None, description=None, language=None, cognitiveProcess=None):
        self.interactivityType = interactivityType
        if learningResourceType is None:
            self.learningResourceType = []
        else:
            self.learningResourceType = learningResourceType
        self.interactivityLevel = interactivityLevel
        self.semanticDensity = semanticDensity
        if intendedEndUserRole is None:
            self.intendedEndUserRole = []
        else:
            self.intendedEndUserRole = intendedEndUserRole
        if context is None:
            self.context = []
        else:
            self.context = context
        if typicalAgeRange is None:
            self.typicalAgeRange = []
        else:
            self.typicalAgeRange = typicalAgeRange
        self.difficulty = difficulty
        self.typicalLearningTime = typicalLearningTime
        if description is None:
            self.description = []
        else:
            self.description = description
        if language is None:
            self.language = []
        else:
            self.language = language
        if cognitiveProcess is None:
            self.cognitiveProcess = []
        else:
            self.cognitiveProcess = cognitiveProcess
    def factory(*args_, **kwargs_):
        if educational.subclass:
            return educational.subclass(*args_, **kwargs_)
        else:
            return educational(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interactivityType(self): return self.interactivityType
    def set_interactivityType(self, interactivityType): self.interactivityType = interactivityType
    def get_learningResourceType(self): return self.learningResourceType
    def set_learningResourceType(self, learningResourceType): self.learningResourceType = learningResourceType
    def add_learningResourceType(self, value): self.learningResourceType.append(value)
    def insert_learningResourceType(self, index, value): self.learningResourceType[index] = value
    def get_interactivityLevel(self): return self.interactivityLevel
    def set_interactivityLevel(self, interactivityLevel): self.interactivityLevel = interactivityLevel
    def get_semanticDensity(self): return self.semanticDensity
    def set_semanticDensity(self, semanticDensity): self.semanticDensity = semanticDensity
    def get_intendedEndUserRole(self): return self.intendedEndUserRole
    def set_intendedEndUserRole(self, intendedEndUserRole): self.intendedEndUserRole = intendedEndUserRole
    def add_intendedEndUserRole(self, value): self.intendedEndUserRole.append(value)
    def insert_intendedEndUserRole(self, index, value): self.intendedEndUserRole[index] = value
    def get_context(self): return self.context
    def set_context(self, context): self.context = context
    def add_context(self, value): self.context.append(value)
    def insert_context(self, index, value): self.context[index] = value
    def get_typicalAgeRange(self): return self.typicalAgeRange
    def set_typicalAgeRange(self, typicalAgeRange): self.typicalAgeRange = typicalAgeRange
    def add_typicalAgeRange(self, value): self.typicalAgeRange.append(value)
    def insert_typicalAgeRange(self, index, value): self.typicalAgeRange[index] = value
    def get_difficulty(self): return self.difficulty
    def set_difficulty(self, difficulty): self.difficulty = difficulty
    def get_typicalLearningTime(self): return self.typicalLearningTime
    def set_typicalLearningTime(self, typicalLearningTime): self.typicalLearningTime = typicalLearningTime
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def add_language(self, value): self.language.append(value)
    def insert_language(self, index, value): self.language[index] = value
    def get_cognitiveProcess(self): return self.cognitiveProcess
    def set_cognitiveProcess(self, cognitiveProcess): self.cognitiveProcess = cognitiveProcess
    def add_cognitiveProcess(self, value): self.cognitiveProcess.append(value)
    def insert_cognitiveProcess(self, index, value): self.cognitiveProcess[index] = value
    def hasContent_(self):
        if (
            self.interactivityType is not None or
            self.learningResourceType or
            self.interactivityLevel is not None or
            self.semanticDensity is not None or
            self.intendedEndUserRole or
            self.context or
            self.typicalAgeRange or
            self.difficulty is not None or
            self.typicalLearningTime is not None or
            self.description or
            self.language or
            self.cognitiveProcess
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='educational', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='educational')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='educational'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='educational', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.interactivityType is not None:
            self.interactivityType.export(outfile, level, namespace_, name_='interactivityType', pretty_print=pretty_print)
        for learningResourceType_ in self.learningResourceType:
            learningResourceType_.export(outfile, level, namespace_, name_='learningResourceType', pretty_print=pretty_print)
        if self.interactivityLevel is not None:
            self.interactivityLevel.export(outfile, level, namespace_, name_='interactivityLevel', pretty_print=pretty_print)
        if self.semanticDensity is not None:
            self.semanticDensity.export(outfile, level, namespace_, name_='semanticDensity', pretty_print=pretty_print)
        for intendedEndUserRole_ in self.intendedEndUserRole:
            intendedEndUserRole_.export(outfile, level, namespace_, name_='intendedEndUserRole', pretty_print=pretty_print)
        for context_ in self.context:
            context_.export(outfile, level, namespace_, name_='context', pretty_print=pretty_print)
        for typicalAgeRange_ in self.typicalAgeRange:
            typicalAgeRange_.export(outfile, level, namespace_, name_='typicalAgeRange', pretty_print=pretty_print)
        if self.difficulty is not None:
            self.difficulty.export(outfile, level, namespace_, name_='difficulty', pretty_print=pretty_print)
        if self.typicalLearningTime is not None:
            self.typicalLearningTime.export(outfile, level, namespace_, name_='typicalLearningTime', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for language_ in self.language:
            language_.export(outfile, level, namespace_, name_='language', pretty_print=pretty_print)
        for cognitiveProcess_ in self.cognitiveProcess:
            cognitiveProcess_.export(outfile, level, namespace_, name_='cognitiveProcess', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='educational'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.interactivityType is not None:
            showIndent(outfile, level)
            outfile.write('interactivityType=model_.interactivityType(\n')
            self.interactivityType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('learningResourceType=[\n')
        level += 1
        for learningResourceType_ in self.learningResourceType:
            showIndent(outfile, level)
            outfile.write('model_.learningResourceType(\n')
            learningResourceType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.interactivityLevel is not None:
            showIndent(outfile, level)
            outfile.write('interactivityLevel=model_.interactivityLevel(\n')
            self.interactivityLevel.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.semanticDensity is not None:
            showIndent(outfile, level)
            outfile.write('semanticDensity=model_.semanticDensity(\n')
            self.semanticDensity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('intendedEndUserRole=[\n')
        level += 1
        for intendedEndUserRole_ in self.intendedEndUserRole:
            showIndent(outfile, level)
            outfile.write('model_.intendedEndUserRole(\n')
            intendedEndUserRole_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('context=[\n')
        level += 1
        for context_ in self.context:
            showIndent(outfile, level)
            outfile.write('model_.context(\n')
            context_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('typicalAgeRange=[\n')
        level += 1
        for typicalAgeRange_ in self.typicalAgeRange:
            showIndent(outfile, level)
            outfile.write('model_.typicalAgeRange(\n')
            typicalAgeRange_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.difficulty is not None:
            showIndent(outfile, level)
            outfile.write('difficulty=model_.difficulty(\n')
            self.difficulty.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.typicalLearningTime is not None:
            showIndent(outfile, level)
            outfile.write('typicalLearningTime=model_.typicalLearningTime(\n')
            self.typicalLearningTime.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.LanguageString(\n')
            description_.exportLiteral(outfile, level, name_='LanguageString')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('language=[\n')
        level += 1
        for language_ in self.language:
            showIndent(outfile, level)
            outfile.write('model_.LanguageId(\n')
            language_.exportLiteral(outfile, level, name_='LanguageId')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cognitiveProcess=[\n')
        level += 1
        for cognitiveProcess_ in self.cognitiveProcess:
            showIndent(outfile, level)
            outfile.write('model_.cognitiveProcess(\n')
            cognitiveProcess_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'interactivityType':
            class_obj_ = self.get_class_obj_(child_, interactivityType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_interactivityType(obj_)
        elif nodeName_ == 'learningResourceType':
            class_obj_ = self.get_class_obj_(child_, learningResourceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.learningResourceType.append(obj_)
        elif nodeName_ == 'interactivityLevel':
            class_obj_ = self.get_class_obj_(child_, interactivityLevel)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_interactivityLevel(obj_)
        elif nodeName_ == 'semanticDensity':
            class_obj_ = self.get_class_obj_(child_, semanticDensity)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_semanticDensity(obj_)
        elif nodeName_ == 'intendedEndUserRole':
            class_obj_ = self.get_class_obj_(child_, intendedEndUserRole)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.intendedEndUserRole.append(obj_)
        elif nodeName_ == 'context':
            class_obj_ = self.get_class_obj_(child_, context)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.context.append(obj_)
        elif nodeName_ == 'typicalAgeRange':
            obj_ = typicalAgeRange.factory()
            obj_.build(child_)
            self.typicalAgeRange.append(obj_)
        elif nodeName_ == 'difficulty':
            class_obj_ = self.get_class_obj_(child_, difficulty)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_difficulty(obj_)
        elif nodeName_ == 'typicalLearningTime':
            obj_ = typicalLearningTime.factory()
            obj_.build(child_)
            self.set_typicalLearningTime(obj_)
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, LanguageString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.description.append(obj_)
        elif nodeName_ == 'language':
            class_obj_ = self.get_class_obj_(child_, LanguageId)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.language.append(obj_)
        elif nodeName_ == 'cognitiveProcess':
            class_obj_ = self.get_class_obj_(child_, cognitiveProcess)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.cognitiveProcess.append(obj_)
# end class educational


class typicalAgeRange(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None):
        super(typicalAgeRange, self).__init__(string, )
        pass
    def factory(*args_, **kwargs_):
        if typicalAgeRange.subclass:
            return typicalAgeRange.subclass(*args_, **kwargs_)
        else:
            return typicalAgeRange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(typicalAgeRange, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='typicalAgeRange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typicalAgeRange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='typicalAgeRange'):
        super(typicalAgeRange, self).exportAttributes(outfile, level, already_processed, namespace_, name_='typicalAgeRange')
    def exportChildren(self, outfile, level, namespace_='', name_='typicalAgeRange', fromsubclass_=False, pretty_print=True):
        super(typicalAgeRange, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='typicalAgeRange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(typicalAgeRange, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(typicalAgeRange, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(typicalAgeRange, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(typicalAgeRange, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class typicalAgeRange


class typicalLearningTime(Duration):
    subclass = None
    superclass = Duration
    def __init__(self, duration=None, description=None, uniqueElementName=None):
        super(typicalLearningTime, self).__init__(duration, description, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        pass
    def factory(*args_, **kwargs_):
        if typicalLearningTime.subclass:
            return typicalLearningTime.subclass(*args_, **kwargs_)
        else:
            return typicalLearningTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(typicalLearningTime, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='typicalLearningTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typicalLearningTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='typicalLearningTime'):
        super(typicalLearningTime, self).exportAttributes(outfile, level, already_processed, namespace_, name_='typicalLearningTime')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='typicalLearningTime', fromsubclass_=False, pretty_print=True):
        super(typicalLearningTime, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='typicalLearningTime'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(typicalLearningTime, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(typicalLearningTime, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(typicalLearningTime, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(typicalLearningTime, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class typicalLearningTime


class rights(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, cost=None, copyrightAndOtherRestrictions=None, description=None, access=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.cost = cost
        self.copyrightAndOtherRestrictions = copyrightAndOtherRestrictions
        self.description = description
        self.access = access
    def factory(*args_, **kwargs_):
        if rights.subclass:
            return rights.subclass(*args_, **kwargs_)
        else:
            return rights(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cost(self): return self.cost
    def set_cost(self, cost): self.cost = cost
    def get_copyrightAndOtherRestrictions(self): return self.copyrightAndOtherRestrictions
    def set_copyrightAndOtherRestrictions(self, copyrightAndOtherRestrictions): self.copyrightAndOtherRestrictions = copyrightAndOtherRestrictions
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_access(self): return self.access
    def set_access(self, access): self.access = access
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.cost is not None or
            self.copyrightAndOtherRestrictions is not None or
            self.description is not None or
            self.access is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='rights', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='rights')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='rights'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='rights', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cost is not None:
            self.cost.export(outfile, level, namespace_, name_='cost', pretty_print=pretty_print)
        if self.copyrightAndOtherRestrictions is not None:
            self.copyrightAndOtherRestrictions.export(outfile, level, namespace_, name_='copyrightAndOtherRestrictions', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        if self.access is not None:
            self.access.export(outfile, level, namespace_, name_='access', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='rights'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.cost is not None:
            showIndent(outfile, level)
            outfile.write('cost=model_.cost(\n')
            self.cost.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.copyrightAndOtherRestrictions is not None:
            showIndent(outfile, level)
            outfile.write('copyrightAndOtherRestrictions=model_.copyrightAndOtherRestrictions(\n')
            self.copyrightAndOtherRestrictions.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access is not None:
            showIndent(outfile, level)
            outfile.write('access=model_.access(\n')
            self.access.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cost':
            class_obj_ = self.get_class_obj_(child_, cost)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_cost(obj_)
        elif nodeName_ == 'copyrightAndOtherRestrictions':
            class_obj_ = self.get_class_obj_(child_, copyrightAndOtherRestrictions)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_copyrightAndOtherRestrictions(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'access':
            obj_ = access.factory()
            obj_.build(child_)
            self.set_access(obj_)
# end class rights


class description(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None):
        super(description, self).__init__(string, )
        pass
    def factory(*args_, **kwargs_):
        if description.subclass:
            return description.subclass(*args_, **kwargs_)
        else:
            return description(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(description, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='description', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='description')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='description'):
        super(description, self).exportAttributes(outfile, level, already_processed, namespace_, name_='description')
    def exportChildren(self, outfile, level, namespace_='', name_='description', fromsubclass_=False, pretty_print=True):
        super(description, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='description'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(description, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(description, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(description, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(description, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class description


class access(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, accessType=None, description=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.accessType = accessType
        self.description = description
    def factory(*args_, **kwargs_):
        if access.subclass:
            return access.subclass(*args_, **kwargs_)
        else:
            return access(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accessType(self): return self.accessType
    def set_accessType(self, accessType): self.accessType = accessType
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.accessType is not None or
            self.description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='access', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='access')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='access'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='access', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accessType is not None:
            self.accessType.export(outfile, level, namespace_, name_='accessType', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='access'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.accessType is not None:
            showIndent(outfile, level)
            outfile.write('accessType=model_.accessType(\n')
            self.accessType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accessType':
            class_obj_ = self.get_class_obj_(child_, accessType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_accessType(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
# end class access


class relation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kind=None, resource=None):
        self.kind = kind
        self.resource = resource
    def factory(*args_, **kwargs_):
        if relation.subclass:
            return relation.subclass(*args_, **kwargs_)
        else:
            return relation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_resource(self): return self.resource
    def set_resource(self, resource): self.resource = resource
    def hasContent_(self):
        if (
            self.kind is not None or
            self.resource is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='relation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='relation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='relation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='relation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_, name_='kind', pretty_print=pretty_print)
        if self.resource is not None:
            self.resource.export(outfile, level, namespace_, name_='resource', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='relation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.kind is not None:
            showIndent(outfile, level)
            outfile.write('kind=model_.kind(\n')
            self.kind.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.resource is not None:
            showIndent(outfile, level)
            outfile.write('resource=model_.resource(\n')
            self.resource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'kind':
            class_obj_ = self.get_class_obj_(child_, kind)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_kind(obj_)
        elif nodeName_ == 'resource':
            obj_ = resource.factory()
            obj_.build(child_)
            self.set_resource(obj_)
# end class relation


class resource(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, identifier=None, description=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.identifier = identifier
        if description is None:
            self.description = []
        else:
            self.description = description
    def factory(*args_, **kwargs_):
        if resource.subclass:
            return resource.subclass(*args_, **kwargs_)
        else:
            return resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_identifier(self): return self.identifier
    def set_identifier(self, identifier): self.identifier = identifier
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def add_description(self, value): self.description.append(value)
    def insert_description(self, index, value): self.description[index] = value
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            self.identifier is not None or
            self.description
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='resource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='resource'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='resource', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.identifier is not None:
            self.identifier.export(outfile, level, namespace_, name_='identifier', pretty_print=pretty_print)
        for description_ in self.description:
            description_.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='resource'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.identifier is not None:
            showIndent(outfile, level)
            outfile.write('identifier=model_.identifier(\n')
            self.identifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('description=[\n')
        level += 1
        for description_ in self.description:
            showIndent(outfile, level)
            outfile.write('model_.LanguageString(\n')
            description_.exportLiteral(outfile, level, name_='LanguageString')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'identifier':
            obj_ = identifier.factory()
            obj_.build(child_)
            self.set_identifier(obj_)
        elif nodeName_ == 'description':
            class_obj_ = self.get_class_obj_(child_, LanguageString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.description.append(obj_)
# end class resource


class annotation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, entity=None, date=None, description=None):
        self.entity = entity
        self.date = date
        self.description = description
    def factory(*args_, **kwargs_):
        if annotation.subclass:
            return annotation.subclass(*args_, **kwargs_)
        else:
            return annotation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.entity is not None or
            self.date is not None or
            self.description is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='annotation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='annotation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='annotation'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='annotation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.entity is not None:
            self.entity.export(outfile, level, namespace_, name_='entity', pretty_print=pretty_print)
        if self.date is not None:
            self.date.export(outfile, level, namespace_, name_='date', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='annotation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.entity is not None:
            showIndent(outfile, level)
            outfile.write('entity=model_.entity(\n')
            self.entity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.date is not None:
            showIndent(outfile, level)
            outfile.write('date=model_.date(\n')
            self.date.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'entity':
            obj_ = entity.factory()
            obj_.build(child_)
            self.set_entity(obj_)
        elif nodeName_ == 'date':
            obj_ = date.factory()
            obj_.build(child_)
            self.set_date(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
# end class annotation


class entity(VCard):
    subclass = None
    superclass = VCard
    def __init__(self, valueOf_=None):
        super(entity, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if entity.subclass:
            return entity.subclass(*args_, **kwargs_)
        else:
            return entity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(entity, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entity')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entity'):
        super(entity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='entity')
    def exportChildren(self, outfile, level, namespace_='', name_='entity', fromsubclass_=False, pretty_print=True):
        super(entity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='entity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(entity, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(entity, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(entity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class entity


class classification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, purpose=None, taxonPath=None, description=None, keyword=None):
        self.purpose = purpose
        if taxonPath is None:
            self.taxonPath = []
        else:
            self.taxonPath = taxonPath
        self.description = description
        if keyword is None:
            self.keyword = []
        else:
            self.keyword = keyword
    def factory(*args_, **kwargs_):
        if classification.subclass:
            return classification.subclass(*args_, **kwargs_)
        else:
            return classification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_purpose(self): return self.purpose
    def set_purpose(self, purpose): self.purpose = purpose
    def get_taxonPath(self): return self.taxonPath
    def set_taxonPath(self, taxonPath): self.taxonPath = taxonPath
    def add_taxonPath(self, value): self.taxonPath.append(value)
    def insert_taxonPath(self, index, value): self.taxonPath[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_keyword(self): return self.keyword
    def set_keyword(self, keyword): self.keyword = keyword
    def add_keyword(self, value): self.keyword.append(value)
    def insert_keyword(self, index, value): self.keyword[index] = value
    def hasContent_(self):
        if (
            self.purpose is not None or
            self.taxonPath or
            self.description is not None or
            self.keyword
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='classification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='classification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='classification'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='classification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.purpose is not None:
            self.purpose.export(outfile, level, namespace_, name_='purpose', pretty_print=pretty_print)
        for taxonPath_ in self.taxonPath:
            taxonPath_.export(outfile, level, namespace_, name_='taxonPath', pretty_print=pretty_print)
        if self.description is not None:
            self.description.export(outfile, level, namespace_, name_='description', pretty_print=pretty_print)
        for keyword_ in self.keyword:
            keyword_.export(outfile, level, namespace_, name_='keyword', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='classification'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.purpose is not None:
            showIndent(outfile, level)
            outfile.write('purpose=model_.purpose(\n')
            self.purpose.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('taxonPath=[\n')
        level += 1
        for taxonPath_ in self.taxonPath:
            showIndent(outfile, level)
            outfile.write('model_.taxonPath(\n')
            taxonPath_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=model_.description(\n')
            self.description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('keyword=[\n')
        level += 1
        for keyword_ in self.keyword:
            showIndent(outfile, level)
            outfile.write('model_.keyword(\n')
            keyword_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'purpose':
            class_obj_ = self.get_class_obj_(child_, purpose)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_purpose(obj_)
        elif nodeName_ == 'taxonPath':
            obj_ = taxonPath.factory()
            obj_.build(child_)
            self.taxonPath.append(obj_)
        elif nodeName_ == 'description':
            obj_ = description.factory()
            obj_.build(child_)
            self.set_description(obj_)
        elif nodeName_ == 'keyword':
            obj_ = keyword.factory()
            obj_.build(child_)
            self.keyword.append(obj_)
# end class classification


class taxonPath(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, taxon=None):
        self.source = source
        if taxon is None:
            self.taxon = []
        else:
            self.taxon = taxon
    def factory(*args_, **kwargs_):
        if taxonPath.subclass:
            return taxonPath.subclass(*args_, **kwargs_)
        else:
            return taxonPath(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_taxon(self): return self.taxon
    def set_taxon(self, taxon): self.taxon = taxon
    def add_taxon(self, value): self.taxon.append(value)
    def insert_taxon(self, index, value): self.taxon[index] = value
    def hasContent_(self):
        if (
            self.source is not None or
            self.taxon
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='taxonPath', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='taxonPath')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='taxonPath'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='taxonPath', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        for taxon_ in self.taxon:
            taxon_.export(outfile, level, namespace_, name_='taxon', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='taxonPath'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.source(\n')
            self.source.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('taxon=[\n')
        level += 1
        for taxon_ in self.taxon:
            showIndent(outfile, level)
            outfile.write('model_.taxon(\n')
            taxon_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            class_obj_ = self.get_class_obj_(child_, source)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'taxon':
            obj_ = taxon.factory()
            obj_.build(child_)
            self.taxon.append(obj_)
# end class taxonPath


class source(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None, uniqueElementName=None, extensiontype_=None):
        super(source, self).__init__(string, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if source.subclass:
            return source.subclass(*args_, **kwargs_)
        else:
            return source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(source, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='source', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='source'):
        super(source, self).exportAttributes(outfile, level, already_processed, namespace_, name_='source')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='source', fromsubclass_=False, pretty_print=True):
        super(source, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(source, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(source, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(source, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(source, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class source


class taxon(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, entry=None):
        self.id = id
        self.entry = entry
    def factory(*args_, **kwargs_):
        if taxon.subclass:
            return taxon.subclass(*args_, **kwargs_)
        else:
            return taxon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def hasContent_(self):
        if (
            self.id is not None or
            self.entry is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='taxon', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='taxon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='taxon'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='taxon', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', pretty_print=pretty_print)
        if self.entry is not None:
            self.entry.export(outfile, level, namespace_, name_='entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='taxon'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=model_.id(\n')
            self.id.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.entry is not None:
            showIndent(outfile, level)
            outfile.write('entry=model_.LanguageString(\n')
            self.entry.exportLiteral(outfile, level, name_='entry')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id':
            obj_ = id.factory()
            obj_.build(child_)
            self.set_id(obj_)
        elif nodeName_ == 'entry':
            class_obj_ = self.get_class_obj_(child_, LanguageString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_entry(obj_)
# end class taxon


class id(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, uniqueElementName=None, valueOf_=None):
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if id.subclass:
            return id.subclass(*args_, **kwargs_)
        else:
            return id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='id', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='id')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='id'):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
#             outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='id', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='id'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class id


class entryTaxon(LanguageString):
    subclass = None
    superclass = LanguageString
    def __init__(self, string=None, uniqueElementName=None):
        super(entryTaxon, self).__init__(string, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        pass
    def factory(*args_, **kwargs_):
        if entryTaxon.subclass:
            return entryTaxon.subclass(*args_, **kwargs_)
        else:
            return entryTaxon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def hasContent_(self):
        if (
            super(entryTaxon, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='entryTaxon', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entryTaxon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='entryTaxon'):
        super(entryTaxon, self).exportAttributes(outfile, level, already_processed, namespace_, name_='entryTaxon')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
#             outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='entryTaxon', fromsubclass_=False, pretty_print=True):
        super(entryTaxon, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='entryTaxon'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(entryTaxon, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(entryTaxon, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(entryTaxon, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(entryTaxon, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class entryTaxon


class sourceValue(source):
    subclass = None
    superclass = source
    def __init__(self, string=None, uniqueElementName=None, valueOf_=None):
        super(sourceValue, self).__init__(string, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if sourceValue.subclass:
            return sourceValue.subclass(*args_, **kwargs_)
        else:
            return sourceValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(sourceValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='sourceValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='sourceValue'):
        super(sourceValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='sourceValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='sourceValue', fromsubclass_=False, pretty_print=True):
        super(sourceValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='sourceValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(sourceValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sourceValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(sourceValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sourceValue


class structureVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if structureVocab.subclass:
            return structureVocab.subclass(*args_, **kwargs_)
        else:
            return structureVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='structureVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='structureVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='structureVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='structureVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='structureVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.structureValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = structureValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class structureVocab


class aggregationLevelVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if aggregationLevelVocab.subclass:
            return aggregationLevelVocab.subclass(*args_, **kwargs_)
        else:
            return aggregationLevelVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aggregationLevelVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aggregationLevelVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aggregationLevelVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='aggregationLevelVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='aggregationLevelVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.aggregationLevelValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = aggregationLevelValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class aggregationLevelVocab


class statusVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if statusVocab.subclass:
            return statusVocab.subclass(*args_, **kwargs_)
        else:
            return statusVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='statusVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='statusVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='statusVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='statusVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='statusVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.statusValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = statusValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class statusVocab


class roleVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if roleVocab.subclass:
            return roleVocab.subclass(*args_, **kwargs_)
        else:
            return roleVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='roleVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='roleVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='roleVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='roleVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.roleValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = roleValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class roleVocab


class roleMetaVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if roleMetaVocab.subclass:
            return roleMetaVocab.subclass(*args_, **kwargs_)
        else:
            return roleMetaVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='roleMetaVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleMetaVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='roleMetaVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='roleMetaVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='roleMetaVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.roleMetaValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = roleMetaValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class roleMetaVocab


class typeVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if typeVocab.subclass:
            return typeVocab.subclass(*args_, **kwargs_)
        else:
            return typeVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='typeVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='typeVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='typeVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='typeVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.typeValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = typeValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class typeVocab


class nameVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if nameVocab.subclass:
            return nameVocab.subclass(*args_, **kwargs_)
        else:
            return nameVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nameVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nameVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='nameVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='nameVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.nameValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = nameValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class nameVocab


class interactivityTypeVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if interactivityTypeVocab.subclass:
            return interactivityTypeVocab.subclass(*args_, **kwargs_)
        else:
            return interactivityTypeVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactivityTypeVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityTypeVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactivityTypeVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='interactivityTypeVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='interactivityTypeVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.interactivityTypeValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = interactivityTypeValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class interactivityTypeVocab


class learningResourceTypeVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if learningResourceTypeVocab.subclass:
            return learningResourceTypeVocab.subclass(*args_, **kwargs_)
        else:
            return learningResourceTypeVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='learningResourceTypeVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='learningResourceTypeVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='learningResourceTypeVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='learningResourceTypeVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='learningResourceTypeVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.learningResourceTypeValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = learningResourceTypeValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class learningResourceTypeVocab


class interactivityLevelVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if interactivityLevelVocab.subclass:
            return interactivityLevelVocab.subclass(*args_, **kwargs_)
        else:
            return interactivityLevelVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactivityLevelVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityLevelVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactivityLevelVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='interactivityLevelVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='interactivityLevelVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.interactivityLevelValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = interactivityLevelValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class interactivityLevelVocab


class semanticDensityVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if semanticDensityVocab.subclass:
            return semanticDensityVocab.subclass(*args_, **kwargs_)
        else:
            return semanticDensityVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='semanticDensityVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='semanticDensityVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='semanticDensityVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='semanticDensityVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='semanticDensityVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.semanticDensityValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = semanticDensityValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class semanticDensityVocab


class intendedEndUserRoleVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if intendedEndUserRoleVocab.subclass:
            return intendedEndUserRoleVocab.subclass(*args_, **kwargs_)
        else:
            return intendedEndUserRoleVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='intendedEndUserRoleVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='intendedEndUserRoleVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='intendedEndUserRoleVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='intendedEndUserRoleVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='intendedEndUserRoleVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.intendedEndUserRoleValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = intendedEndUserRoleValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class intendedEndUserRoleVocab


class contextVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if contextVocab.subclass:
            return contextVocab.subclass(*args_, **kwargs_)
        else:
            return contextVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contextVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contextVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contextVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contextVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='contextVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.contextValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = contextValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class contextVocab


class difficultyVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if difficultyVocab.subclass:
            return difficultyVocab.subclass(*args_, **kwargs_)
        else:
            return difficultyVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='difficultyVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='difficultyVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='difficultyVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='difficultyVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='difficultyVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.difficultyValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = difficultyValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class difficultyVocab


class cognitiveProcessVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cognitiveProcessVocab.subclass:
            return cognitiveProcessVocab.subclass(*args_, **kwargs_)
        else:
            return cognitiveProcessVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cognitiveProcessVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cognitiveProcessVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cognitiveProcessVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cognitiveProcessVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cognitiveProcessVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.cognitiveProcessValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = cognitiveProcessValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class cognitiveProcessVocab


class costVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if costVocab.subclass:
            return costVocab.subclass(*args_, **kwargs_)
        else:
            return costVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='costVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='costVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='costVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='costVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='costVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.costValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = costValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class costVocab


class copyrightAndOtherRestrictionsVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if copyrightAndOtherRestrictionsVocab.subclass:
            return copyrightAndOtherRestrictionsVocab.subclass(*args_, **kwargs_)
        else:
            return copyrightAndOtherRestrictionsVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='copyrightAndOtherRestrictionsVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='copyrightAndOtherRestrictionsVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='copyrightAndOtherRestrictionsVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='copyrightAndOtherRestrictionsVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='copyrightAndOtherRestrictionsVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.copyrightAndOtherRestrictionsValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = copyrightAndOtherRestrictionsValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class copyrightAndOtherRestrictionsVocab


class accessTypeVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if accessTypeVocab.subclass:
            return accessTypeVocab.subclass(*args_, **kwargs_)
        else:
            return accessTypeVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='accessTypeVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessTypeVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='accessTypeVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='accessTypeVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='accessTypeVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.accessTypeValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = accessTypeValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class accessTypeVocab


class kindVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if kindVocab.subclass:
            return kindVocab.subclass(*args_, **kwargs_)
        else:
            return kindVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='kindVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='kindVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='kindVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='kindVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='kindVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.kindValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = kindValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class kindVocab


class purposeVocab(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, source=None, value=None, extensiontype_=None):
        self.source = source
        self.value = value
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if purposeVocab.subclass:
            return purposeVocab.subclass(*args_, **kwargs_)
        else:
            return purposeVocab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.source is not None or
            self.value is not None
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='purposeVocab', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='purposeVocab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='purposeVocab'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='purposeVocab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='purposeVocab'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.sourceValue(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.purposeValue(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'source':
            obj_ = sourceValue.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'value':
            obj_ = purposeValue.factory()
            obj_.build(child_)
            self.set_value(obj_)
# end class purposeVocab


class purpose(purposeVocab):
    subclass = None
    superclass = purposeVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(purpose, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if purpose.subclass:
            return purpose.subclass(*args_, **kwargs_)
        else:
            return purpose(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(purpose, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='purpose', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='purpose')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='purpose'):
        super(purpose, self).exportAttributes(outfile, level, already_processed, namespace_, name_='purpose')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='purpose', fromsubclass_=False, pretty_print=True):
        super(purpose, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='purpose'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(purpose, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(purpose, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(purpose, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(purpose, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class purpose


class kind(kindVocab):
    subclass = None
    superclass = kindVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(kind, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if kind.subclass:
            return kind.subclass(*args_, **kwargs_)
        else:
            return kind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(kind, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='kind', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='kind')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='kind'):
        super(kind, self).exportAttributes(outfile, level, already_processed, namespace_, name_='kind')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='kind', fromsubclass_=False, pretty_print=True):
        super(kind, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='kind'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(kind, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(kind, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(kind, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(kind, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class kind


class accessType(accessTypeVocab):
    subclass = None
    superclass = accessTypeVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(accessType, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if accessType.subclass:
            return accessType.subclass(*args_, **kwargs_)
        else:
            return accessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(accessType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='accessType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='accessType'):
        super(accessType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='accessType')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='accessType', fromsubclass_=False, pretty_print=True):
        super(accessType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='accessType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(accessType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(accessType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(accessType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(accessType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class accessType


class copyrightAndOtherRestrictions(copyrightAndOtherRestrictionsVocab):
    subclass = None
    superclass = copyrightAndOtherRestrictionsVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(copyrightAndOtherRestrictions, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if copyrightAndOtherRestrictions.subclass:
            return copyrightAndOtherRestrictions.subclass(*args_, **kwargs_)
        else:
            return copyrightAndOtherRestrictions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(copyrightAndOtherRestrictions, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='copyrightAndOtherRestrictions', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='copyrightAndOtherRestrictions')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='copyrightAndOtherRestrictions'):
        super(copyrightAndOtherRestrictions, self).exportAttributes(outfile, level, already_processed, namespace_, name_='copyrightAndOtherRestrictions')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='copyrightAndOtherRestrictions', fromsubclass_=False, pretty_print=True):
        super(copyrightAndOtherRestrictions, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='copyrightAndOtherRestrictions'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(copyrightAndOtherRestrictions, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(copyrightAndOtherRestrictions, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(copyrightAndOtherRestrictions, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(copyrightAndOtherRestrictions, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class copyrightAndOtherRestrictions


class cost(costVocab):
    subclass = None
    superclass = costVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(cost, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cost.subclass:
            return cost.subclass(*args_, **kwargs_)
        else:
            return cost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(cost, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cost', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cost')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cost'):
        super(cost, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cost')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='cost', fromsubclass_=False, pretty_print=True):
        super(cost, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cost'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(cost, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cost, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(cost, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(cost, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class cost


class cognitiveProcess(cognitiveProcessVocab):
    subclass = None
    superclass = cognitiveProcessVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(cognitiveProcess, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cognitiveProcess.subclass:
            return cognitiveProcess.subclass(*args_, **kwargs_)
        else:
            return cognitiveProcess(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(cognitiveProcess, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cognitiveProcess', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cognitiveProcess')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cognitiveProcess'):
        super(cognitiveProcess, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cognitiveProcess')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='cognitiveProcess', fromsubclass_=False, pretty_print=True):
        super(cognitiveProcess, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cognitiveProcess'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(cognitiveProcess, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cognitiveProcess, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(cognitiveProcess, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(cognitiveProcess, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class cognitiveProcess


class difficulty(difficultyVocab):
    subclass = None
    superclass = difficultyVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(difficulty, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if difficulty.subclass:
            return difficulty.subclass(*args_, **kwargs_)
        else:
            return difficulty(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(difficulty, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='difficulty', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='difficulty')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='difficulty'):
        super(difficulty, self).exportAttributes(outfile, level, already_processed, namespace_, name_='difficulty')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='difficulty', fromsubclass_=False, pretty_print=True):
        super(difficulty, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='difficulty'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(difficulty, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(difficulty, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(difficulty, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(difficulty, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class difficulty


class context(contextVocab):
    subclass = None
    superclass = contextVocab
    def __init__(self, source=None, value=None, extensiontype_=None):
        super(context, self).__init__(source, value, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if context.subclass:
            return context.subclass(*args_, **kwargs_)
        else:
            return context(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(context, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='context', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='context')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='context'):
        super(context, self).exportAttributes(outfile, level, already_processed, namespace_, name_='context')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='context', fromsubclass_=False, pretty_print=True):
        super(context, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='context'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(context, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(context, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(context, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(context, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class context


class intendedEndUserRole(intendedEndUserRoleVocab):
    subclass = None
    superclass = intendedEndUserRoleVocab
    def __init__(self, source=None, value=None, extensiontype_=None):
        super(intendedEndUserRole, self).__init__(source, value, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if intendedEndUserRole.subclass:
            return intendedEndUserRole.subclass(*args_, **kwargs_)
        else:
            return intendedEndUserRole(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(intendedEndUserRole, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='intendedEndUserRole', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='intendedEndUserRole')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='intendedEndUserRole'):
        super(intendedEndUserRole, self).exportAttributes(outfile, level, already_processed, namespace_, name_='intendedEndUserRole')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='intendedEndUserRole', fromsubclass_=False, pretty_print=True):
        super(intendedEndUserRole, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='intendedEndUserRole'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(intendedEndUserRole, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(intendedEndUserRole, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(intendedEndUserRole, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(intendedEndUserRole, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class intendedEndUserRole


class semanticDensity(semanticDensityVocab):
    subclass = None
    superclass = semanticDensityVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(semanticDensity, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if semanticDensity.subclass:
            return semanticDensity.subclass(*args_, **kwargs_)
        else:
            return semanticDensity(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(semanticDensity, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='semanticDensity', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='semanticDensity')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='semanticDensity'):
        super(semanticDensity, self).exportAttributes(outfile, level, already_processed, namespace_, name_='semanticDensity')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='semanticDensity', fromsubclass_=False, pretty_print=True):
        super(semanticDensity, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='semanticDensity'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(semanticDensity, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(semanticDensity, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(semanticDensity, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(semanticDensity, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class semanticDensity


class interactivityLevel(interactivityLevelVocab):
    subclass = None
    superclass = interactivityLevelVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(interactivityLevel, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if interactivityLevel.subclass:
            return interactivityLevel.subclass(*args_, **kwargs_)
        else:
            return interactivityLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(interactivityLevel, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactivityLevel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactivityLevel'):
        super(interactivityLevel, self).exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityLevel')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='interactivityLevel', fromsubclass_=False, pretty_print=True):
        super(interactivityLevel, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='interactivityLevel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(interactivityLevel, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interactivityLevel, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(interactivityLevel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(interactivityLevel, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class interactivityLevel


class learningResourceType(learningResourceTypeVocab):
    subclass = None
    superclass = learningResourceTypeVocab
    def __init__(self, source=None, value=None, extensiontype_=None):
        super(learningResourceType, self).__init__(source, value, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if learningResourceType.subclass:
            return learningResourceType.subclass(*args_, **kwargs_)
        else:
            return learningResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(learningResourceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='learningResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='learningResourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='learningResourceType'):
        super(learningResourceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='learningResourceType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='learningResourceType', fromsubclass_=False, pretty_print=True):
        super(learningResourceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='learningResourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(learningResourceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(learningResourceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(learningResourceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(learningResourceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class learningResourceType


class interactivityType(interactivityTypeVocab):
    subclass = None
    superclass = interactivityTypeVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(interactivityType, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if interactivityType.subclass:
            return interactivityType.subclass(*args_, **kwargs_)
        else:
            return interactivityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(interactivityType, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactivityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactivityType'):
        super(interactivityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityType')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='interactivityType', fromsubclass_=False, pretty_print=True):
        super(interactivityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='interactivityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(interactivityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interactivityType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(interactivityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(interactivityType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class interactivityType


class name(nameVocab):
    subclass = None
    superclass = nameVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(name, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if name.subclass:
            return name.subclass(*args_, **kwargs_)
        else:
            return name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(name, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='name'):
        super(name, self).exportAttributes(outfile, level, already_processed, namespace_, name_='name')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='name', fromsubclass_=False, pretty_print=True):
        super(name, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='name'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(name, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(name, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(name, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(name, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class name


class type_(typeVocab):
    subclass = None
    superclass = typeVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(type_, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if type_.subclass:
            return type_.subclass(*args_, **kwargs_)
        else:
            return type_(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(type_, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='type'):
        super(type_, self).exportAttributes(outfile, level, already_processed, namespace_, name_='type')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='type', fromsubclass_=False, pretty_print=True):
        super(type_, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(type_, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(type_, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(type_, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(type_, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class type_


class roleMeta(roleMetaVocab):
    subclass = None
    superclass = roleMetaVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(roleMeta, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if roleMeta.subclass:
            return roleMeta.subclass(*args_, **kwargs_)
        else:
            return roleMeta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(roleMeta, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='roleMeta', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleMeta')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='roleMeta'):
        super(roleMeta, self).exportAttributes(outfile, level, already_processed, namespace_, name_='roleMeta')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='roleMeta', fromsubclass_=False, pretty_print=True):
        super(roleMeta, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='roleMeta'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(roleMeta, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(roleMeta, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(roleMeta, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(roleMeta, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class roleMeta


class role(roleVocab):
    subclass = None
    superclass = roleVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(role, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if role.subclass:
            return role.subclass(*args_, **kwargs_)
        else:
            return role(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(role, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='role', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='role')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='role'):
        super(role, self).exportAttributes(outfile, level, already_processed, namespace_, name_='role')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='role', fromsubclass_=False, pretty_print=True):
        super(role, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='role'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(role, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(role, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(role, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(role, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class role


class status(statusVocab):
    subclass = None
    superclass = statusVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(status, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if status.subclass:
            return status.subclass(*args_, **kwargs_)
        else:
            return status(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(status, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='status', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='status')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='status'):
        super(status, self).exportAttributes(outfile, level, already_processed, namespace_, name_='status')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='status', fromsubclass_=False, pretty_print=True):
        super(status, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='status'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(status, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(status, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(status, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(status, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class status


class aggregationLevel(aggregationLevelVocab):
    subclass = None
    superclass = aggregationLevelVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(aggregationLevel, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if aggregationLevel.subclass:
            return aggregationLevel.subclass(*args_, **kwargs_)
        else:
            return aggregationLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(aggregationLevel, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aggregationLevel', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aggregationLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aggregationLevel'):
        super(aggregationLevel, self).exportAttributes(outfile, level, already_processed, namespace_, name_='aggregationLevel')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='aggregationLevel', fromsubclass_=False, pretty_print=True):
        super(aggregationLevel, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='aggregationLevel'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(aggregationLevel, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(aggregationLevel, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(aggregationLevel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(aggregationLevel, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class aggregationLevel


class structure(structureVocab):
    subclass = None
    superclass = structureVocab
    def __init__(self, source=None, value=None, uniqueElementName=None, extensiontype_=None):
        super(structure, self).__init__(source, value, extensiontype_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if structure.subclass:
            return structure.subclass(*args_, **kwargs_)
        else:
            return structure(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(structure, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='structure', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='structure')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='structure'):
        super(structure, self).exportAttributes(outfile, level, already_processed, namespace_, name_='structure')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='structure', fromsubclass_=False, pretty_print=True):
        super(structure, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='structure'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(structure, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(structure, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(structure, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(structure, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class structure


class purposeValue(purpose):
    subclass = None
    superclass = purpose
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(purposeValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if purposeValue.subclass:
            return purposeValue.subclass(*args_, **kwargs_)
        else:
            return purposeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(purposeValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='purposeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='purposeValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='purposeValue'):
        super(purposeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='purposeValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='purposeValue', fromsubclass_=False, pretty_print=True):
        super(purposeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='purposeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(purposeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(purposeValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(purposeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class purposeValue


class kindValue(kind):
    subclass = None
    superclass = kind
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(kindValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if kindValue.subclass:
            return kindValue.subclass(*args_, **kwargs_)
        else:
            return kindValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(kindValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='kindValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='kindValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='kindValue'):
        super(kindValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='kindValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='kindValue', fromsubclass_=False, pretty_print=True):
        super(kindValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='kindValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(kindValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(kindValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(kindValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class kindValue


class accessTypeValue(accessType):
    subclass = None
    superclass = accessType
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(accessTypeValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if accessTypeValue.subclass:
            return accessTypeValue.subclass(*args_, **kwargs_)
        else:
            return accessTypeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(accessTypeValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='accessTypeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessTypeValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='accessTypeValue'):
        super(accessTypeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='accessTypeValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='accessTypeValue', fromsubclass_=False, pretty_print=True):
        super(accessTypeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='accessTypeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(accessTypeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(accessTypeValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(accessTypeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accessTypeValue


class copyrightAndOtherRestrictionsValue(copyrightAndOtherRestrictions):
    subclass = None
    superclass = copyrightAndOtherRestrictions
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(copyrightAndOtherRestrictionsValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if copyrightAndOtherRestrictionsValue.subclass:
            return copyrightAndOtherRestrictionsValue.subclass(*args_, **kwargs_)
        else:
            return copyrightAndOtherRestrictionsValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(copyrightAndOtherRestrictionsValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='copyrightAndOtherRestrictionsValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='copyrightAndOtherRestrictionsValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='copyrightAndOtherRestrictionsValue'):
        super(copyrightAndOtherRestrictionsValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='copyrightAndOtherRestrictionsValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='copyrightAndOtherRestrictionsValue', fromsubclass_=False, pretty_print=True):
        super(copyrightAndOtherRestrictionsValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='copyrightAndOtherRestrictionsValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(copyrightAndOtherRestrictionsValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(copyrightAndOtherRestrictionsValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(copyrightAndOtherRestrictionsValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class copyrightAndOtherRestrictionsValue


class costValue(cost):
    subclass = None
    superclass = cost
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(costValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if costValue.subclass:
            return costValue.subclass(*args_, **kwargs_)
        else:
            return costValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(costValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='costValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='costValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='costValue'):
        super(costValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='costValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='costValue', fromsubclass_=False, pretty_print=True):
        super(costValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='costValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(costValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(costValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(costValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class costValue


class cognitiveProcessValue(cognitiveProcess):
    subclass = None
    superclass = cognitiveProcess
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(cognitiveProcessValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cognitiveProcessValue.subclass:
            return cognitiveProcessValue.subclass(*args_, **kwargs_)
        else:
            return cognitiveProcessValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(cognitiveProcessValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cognitiveProcessValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cognitiveProcessValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cognitiveProcessValue'):
        super(cognitiveProcessValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cognitiveProcessValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cognitiveProcessValue', fromsubclass_=False, pretty_print=True):
        super(cognitiveProcessValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cognitiveProcessValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(cognitiveProcessValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cognitiveProcessValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(cognitiveProcessValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cognitiveProcessValue


class difficultyValue(difficulty):
    subclass = None
    superclass = difficulty
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(difficultyValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if difficultyValue.subclass:
            return difficultyValue.subclass(*args_, **kwargs_)
        else:
            return difficultyValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(difficultyValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='difficultyValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='difficultyValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='difficultyValue'):
        super(difficultyValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='difficultyValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='difficultyValue', fromsubclass_=False, pretty_print=True):
        super(difficultyValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='difficultyValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(difficultyValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(difficultyValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(difficultyValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class difficultyValue


class contextValue(context):
    subclass = None
    superclass = context
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(contextValue, self).__init__(source, value, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if contextValue.subclass:
            return contextValue.subclass(*args_, **kwargs_)
        else:
            return contextValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(contextValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='contextValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contextValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='contextValue'):
        super(contextValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='contextValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='contextValue', fromsubclass_=False, pretty_print=True):
        super(contextValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='contextValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(contextValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(contextValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(contextValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class contextValue


class intendedEndUserRoleValue(intendedEndUserRole):
    subclass = None
    superclass = intendedEndUserRole
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(intendedEndUserRoleValue, self).__init__(source, value, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if intendedEndUserRoleValue.subclass:
            return intendedEndUserRoleValue.subclass(*args_, **kwargs_)
        else:
            return intendedEndUserRoleValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(intendedEndUserRoleValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='intendedEndUserRoleValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='intendedEndUserRoleValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='intendedEndUserRoleValue'):
        super(intendedEndUserRoleValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='intendedEndUserRoleValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='intendedEndUserRoleValue', fromsubclass_=False, pretty_print=True):
        super(intendedEndUserRoleValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='intendedEndUserRoleValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(intendedEndUserRoleValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(intendedEndUserRoleValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(intendedEndUserRoleValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class intendedEndUserRoleValue


class semanticDensityValue(semanticDensity):
    subclass = None
    superclass = semanticDensity
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(semanticDensityValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if semanticDensityValue.subclass:
            return semanticDensityValue.subclass(*args_, **kwargs_)
        else:
            return semanticDensityValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(semanticDensityValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='semanticDensityValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='semanticDensityValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='semanticDensityValue'):
        super(semanticDensityValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='semanticDensityValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='semanticDensityValue', fromsubclass_=False, pretty_print=True):
        super(semanticDensityValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='semanticDensityValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(semanticDensityValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(semanticDensityValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(semanticDensityValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class semanticDensityValue


class interactivityLevelValue(interactivityLevel):
    subclass = None
    superclass = interactivityLevel
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(interactivityLevelValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if interactivityLevelValue.subclass:
            return interactivityLevelValue.subclass(*args_, **kwargs_)
        else:
            return interactivityLevelValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(interactivityLevelValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactivityLevelValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityLevelValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactivityLevelValue'):
        super(interactivityLevelValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityLevelValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='interactivityLevelValue', fromsubclass_=False, pretty_print=True):
        super(interactivityLevelValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='interactivityLevelValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(interactivityLevelValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interactivityLevelValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(interactivityLevelValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class interactivityLevelValue


class learningResourceTypeValue(learningResourceType):
    subclass = None
    superclass = learningResourceType
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(learningResourceTypeValue, self).__init__(source, value, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if learningResourceTypeValue.subclass:
            return learningResourceTypeValue.subclass(*args_, **kwargs_)
        else:
            return learningResourceTypeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(learningResourceTypeValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='learningResourceTypeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='learningResourceTypeValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='learningResourceTypeValue'):
        super(learningResourceTypeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='learningResourceTypeValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='learningResourceTypeValue', fromsubclass_=False, pretty_print=True):
        super(learningResourceTypeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='learningResourceTypeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(learningResourceTypeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(learningResourceTypeValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(learningResourceTypeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class learningResourceTypeValue


class interactivityTypeValue(interactivityType):
    subclass = None
    superclass = interactivityType
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(interactivityTypeValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if interactivityTypeValue.subclass:
            return interactivityTypeValue.subclass(*args_, **kwargs_)
        else:
            return interactivityTypeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(interactivityTypeValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='interactivityTypeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityTypeValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='interactivityTypeValue'):
        super(interactivityTypeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='interactivityTypeValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='interactivityTypeValue', fromsubclass_=False, pretty_print=True):
        super(interactivityTypeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='interactivityTypeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(interactivityTypeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interactivityTypeValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(interactivityTypeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class interactivityTypeValue


class nameValue(name):
    subclass = None
    superclass = name
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(nameValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if nameValue.subclass:
            return nameValue.subclass(*args_, **kwargs_)
        else:
            return nameValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(nameValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='nameValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nameValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='nameValue'):
        super(nameValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='nameValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='nameValue', fromsubclass_=False, pretty_print=True):
        super(nameValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='nameValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(nameValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(nameValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(nameValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class nameValue


class typeValue(type_):
    subclass = None
    superclass = type_
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(typeValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if typeValue.subclass:
            return typeValue.subclass(*args_, **kwargs_)
        else:
            return typeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(typeValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='typeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='typeValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='typeValue'):
        super(typeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='typeValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='typeValue', fromsubclass_=False, pretty_print=True):
        super(typeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='typeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(typeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(typeValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(typeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class typeValue


class roleMetaValue(roleMeta):
    subclass = None
    superclass = roleMeta
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(roleMetaValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if roleMetaValue.subclass:
            return roleMetaValue.subclass(*args_, **kwargs_)
        else:
            return roleMetaValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(roleMetaValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='roleMetaValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleMetaValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='roleMetaValue'):
        super(roleMetaValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='roleMetaValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='roleMetaValue', fromsubclass_=False, pretty_print=True):
        super(roleMetaValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='roleMetaValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(roleMetaValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(roleMetaValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(roleMetaValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class roleMetaValue


class roleValue(role):
    subclass = None
    superclass = role
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(roleValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if roleValue.subclass:
            return roleValue.subclass(*args_, **kwargs_)
        else:
            return roleValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(roleValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='roleValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='roleValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='roleValue'):
        super(roleValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='roleValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='roleValue', fromsubclass_=False, pretty_print=True):
        super(roleValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='roleValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(roleValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(roleValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(roleValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class roleValue


class statusValue(status):
    subclass = None
    superclass = status
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(statusValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if statusValue.subclass:
            return statusValue.subclass(*args_, **kwargs_)
        else:
            return statusValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(statusValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='statusValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='statusValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='statusValue'):
        super(statusValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='statusValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='statusValue', fromsubclass_=False, pretty_print=True):
        super(statusValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='statusValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(statusValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(statusValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(statusValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class statusValue


class aggregationLevelValue(aggregationLevel):
    subclass = None
    superclass = aggregationLevel
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(aggregationLevelValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if aggregationLevelValue.subclass:
            return aggregationLevelValue.subclass(*args_, **kwargs_)
        else:
            return aggregationLevelValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(aggregationLevelValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='aggregationLevelValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='aggregationLevelValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='aggregationLevelValue'):
        super(aggregationLevelValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='aggregationLevelValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='aggregationLevelValue', fromsubclass_=False, pretty_print=True):
        super(aggregationLevelValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='aggregationLevelValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(aggregationLevelValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(aggregationLevelValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(aggregationLevelValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class aggregationLevelValue


class structureValue(structure):
    subclass = None
    superclass = structure
    def __init__(self, source=None, value=None, uniqueElementName=None, valueOf_=None):
        super(structureValue, self).__init__(source, value, uniqueElementName, valueOf_, )
        self.uniqueElementName = _cast(None, uniqueElementName)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if structureValue.subclass:
            return structureValue.subclass(*args_, **kwargs_)
        else:
            return structureValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_uniqueElementName(self): return self.uniqueElementName
    def set_uniqueElementName(self, uniqueElementName): self.uniqueElementName = uniqueElementName
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(structureValue, self).hasContent_()
            ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='structureValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='structureValue')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='structureValue'):
        super(structureValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='structureValue')
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            outfile.write(' uniqueElementName=%s' % (self.gds_format_string(quote_attrib(self.uniqueElementName).encode(ExternalEncoding), input_name='uniqueElementName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='structureValue', fromsubclass_=False, pretty_print=True):
        super(structureValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='structureValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uniqueElementName is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            showIndent(outfile, level)
            outfile.write('uniqueElementName = "%s",\n' % (self.uniqueElementName,))
        super(structureValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(structureValue, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uniqueElementName', node)
        if value is not None and 'uniqueElementName' not in already_processed:
            already_processed.add('uniqueElementName')
            self.uniqueElementName = value
        super(structureValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class structureValue


GDSClassesMapping = {
    'description': LanguageString,
    'language': LanguageId,
    'contribute': contributeMeta,
    'value': purposeValue,
    'entity': VCard,
    'source': sourceValue,
    'role': roleMeta,
    'duration': DurationValue,
    'entry': LanguageString,
    'dateTime': DateTimeValue,
    'string': LangString,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'lom'
        rootClass = lom
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'lom'
        rootClass = lom
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    rootElement = rootObj.to_etree(None, name_=rootTag)
    content = etree_.tostring(rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'lom'
        rootClass = lom
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="lom",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'lom'
        rootClass = lom
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from lom import *\n\n')
    sys.stdout.write('from datetime import datetime as datetime_\n\n')
    sys.stdout.write('import lom as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "DateTime",
    "DateTimeValue",
    "Duration",
    "DurationValue",
    "LangString",
    "LanguageId",
    "LanguageString",
    "VCard",
    "access",
    "accessType",
    "accessTypeValue",
    "accessTypeVocab",
    "aggregationLevel",
    "aggregationLevelValue",
    "aggregationLevelVocab",
    "annotation",
    "catalog",
    "classification",
    "cognitiveProcess",
    "cognitiveProcessValue",
    "cognitiveProcessVocab",
    "context",
    "contextValue",
    "contextVocab",
    "contribute",
    "contributeMeta",
    "copyrightAndOtherRestrictions",
    "copyrightAndOtherRestrictionsValue",
    "copyrightAndOtherRestrictionsVocab",
    "cost",
    "costValue",
    "costVocab",
    "coverage",
    "date",
    "description",
    "difficulty",
    "difficultyValue",
    "difficultyVocab",
    "duration",
    "educational",
    "entity",
    "entry",
    "entryTaxon",
    "format",
    "general",
    "id",
    "identifier",
    "installationRemarks",
    "intendedEndUserRole",
    "intendedEndUserRoleValue",
    "intendedEndUserRoleVocab",
    "interactivityLevel",
    "interactivityLevelValue",
    "interactivityLevelVocab",
    "interactivityType",
    "interactivityTypeValue",
    "interactivityTypeVocab",
    "keyword",
    "kind",
    "kindValue",
    "kindVocab",
    "language",
    "learningResourceType",
    "learningResourceTypeValue",
    "learningResourceTypeVocab",
    "lifeCycle",
    "location",
    "lom",
    "maximumVersion",
    "metaMetadata",
    "metadataSchema",
    "minimumVersion",
    "name",
    "nameValue",
    "nameVocab",
    "orComposite",
    "otherPlatformRequirements",
    "purpose",
    "purposeValue",
    "purposeVocab",
    "relation",
    "requirement",
    "resource",
    "rights",
    "role",
    "roleMeta",
    "roleMetaValue",
    "roleMetaVocab",
    "roleValue",
    "roleVocab",
    "semanticDensity",
    "semanticDensityValue",
    "semanticDensityVocab",
    "size",
    "source",
    "sourceValue",
    "status",
    "statusValue",
    "statusVocab",
    "structure",
    "structureValue",
    "structureVocab",
    "taxon",
    "taxonPath",
    "technical",
    "title",
    "typeValue",
    "typeVocab",
    "type_",
    "typicalAgeRange",
    "typicalLearningTime",
    "version"
    ]
